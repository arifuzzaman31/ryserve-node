
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Owner
 * 
 */
export type Owner = $Result.DefaultSelection<Prisma.$OwnerPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model wishList
 * 
 */
export type wishList = $Result.DefaultSelection<Prisma.$wishListPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model SeatBed
 * 
 */
export type SeatBed = $Result.DefaultSelection<Prisma.$SeatBedPayload>
/**
 * Model Food
 * 
 */
export type Food = $Result.DefaultSelection<Prisma.$FoodPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model Events
 * 
 */
export type Events = $Result.DefaultSelection<Prisma.$EventsPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Amenities
 * 
 */
export type Amenities = $Result.DefaultSelection<Prisma.$AmenitiesPayload>
/**
 * Model Cuisine
 * 
 */
export type Cuisine = $Result.DefaultSelection<Prisma.$CuisinePayload>
/**
 * Model Evbooking
 * 
 */
export type Evbooking = $Result.DefaultSelection<Prisma.$EvbookingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const loggerType: {
  DASHBOARD_USER: 'DASHBOARD_USER',
  APPS_USER: 'APPS_USER'
};

export type loggerType = (typeof loggerType)[keyof typeof loggerType]


export const UserType: {
  CRM_EDITOR: 'CRM_EDITOR',
  BUSINESS_OWNER: 'BUSINESS_OWNER',
  BUSINESS_MANAGER: 'BUSINESS_MANAGER',
  LISTING_MANAGER: 'LISTING_MANAGER',
  CUSTOMER: 'CUSTOMER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const BusinessCategory: {
  HOTEL: 'HOTEL',
  RESTAURANT: 'RESTAURANT',
  SERVICE_APARTMENT: 'SERVICE_APARTMENT',
  MOVIE_THEATER: 'MOVIE_THEATER',
  SPA: 'SPA',
  OTHERS: 'OTHERS'
};

export type BusinessCategory = (typeof BusinessCategory)[keyof typeof BusinessCategory]


export const Category: {
  ROOM: 'ROOM',
  TABLE: 'TABLE',
  TICKET: 'TICKET',
  APPOINTMENT: 'APPOINTMENT'
};

export type Category = (typeof Category)[keyof typeof Category]


export const compType: {
  KING: 'KING',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
  SINGLE: 'SINGLE',
  TWIN: 'TWIN',
  QUEEN: 'QUEEN'
};

export type compType = (typeof compType)[keyof typeof compType]


export const ContentType: {
  FOOD: 'FOOD',
  PROPERTY: 'PROPERTY'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const BookingStatus: {
  CONFIRMED: 'CONFIRMED',
  DEACTIVE: 'DEACTIVE',
  ON_HOLD: 'ON_HOLD',
  CANCELED: 'CANCELED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentStatus: {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  OTHER: 'OTHER'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type loggerType = $Enums.loggerType

export const loggerType: typeof $Enums.loggerType

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type BusinessCategory = $Enums.BusinessCategory

export const BusinessCategory: typeof $Enums.BusinessCategory

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type compType = $Enums.compType

export const compType: typeof $Enums.compType

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sessions
 * const sessions = await prisma.session.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): Prisma.OwnerDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.wishList`: Exposes CRUD operations for the **wishList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishLists
    * const wishLists = await prisma.wishList.findMany()
    * ```
    */
  get wishList(): Prisma.wishListDelegate<ExtArgs>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs>;

  /**
   * `prisma.seatBed`: Exposes CRUD operations for the **SeatBed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeatBeds
    * const seatBeds = await prisma.seatBed.findMany()
    * ```
    */
  get seatBed(): Prisma.SeatBedDelegate<ExtArgs>;

  /**
   * `prisma.food`: Exposes CRUD operations for the **Food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foods
    * const foods = await prisma.food.findMany()
    * ```
    */
  get food(): Prisma.FoodDelegate<ExtArgs>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.amenities`: Exposes CRUD operations for the **Amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenities.findMany()
    * ```
    */
  get amenities(): Prisma.AmenitiesDelegate<ExtArgs>;

  /**
   * `prisma.cuisine`: Exposes CRUD operations for the **Cuisine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuisines
    * const cuisines = await prisma.cuisine.findMany()
    * ```
    */
  get cuisine(): Prisma.CuisineDelegate<ExtArgs>;

  /**
   * `prisma.evbooking`: Exposes CRUD operations for the **Evbooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evbookings
    * const evbookings = await prisma.evbooking.findMany()
    * ```
    */
  get evbooking(): Prisma.EvbookingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Session: 'Session',
    Owner: 'Owner',
    User: 'User',
    RolePermission: 'RolePermission',
    wishList: 'wishList',
    Property: 'Property',
    Branch: 'Branch',
    Table: 'Table',
    SeatBed: 'SeatBed',
    Food: 'Food',
    Section: 'Section',
    Events: 'Events',
    Booking: 'Booking',
    Payment: 'Payment',
    Amenities: 'Amenities',
    Cuisine: 'Cuisine',
    Evbooking: 'Evbooking'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "session" | "owner" | "user" | "rolePermission" | "wishList" | "property" | "branch" | "table" | "seatBed" | "food" | "section" | "events" | "booking" | "payment" | "amenities" | "cuisine" | "evbooking"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Owner: {
        payload: Prisma.$OwnerPayload<ExtArgs>
        fields: Prisma.OwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findFirst: {
            args: Prisma.OwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findMany: {
            args: Prisma.OwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          create: {
            args: Prisma.OwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          createMany: {
            args: Prisma.OwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          delete: {
            args: Prisma.OwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          update: {
            args: Prisma.OwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          aggregate: {
            args: Prisma.OwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwner>
          }
          groupBy: {
            args: Prisma.OwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      wishList: {
        payload: Prisma.$wishListPayload<ExtArgs>
        fields: Prisma.wishListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wishListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wishListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>
          }
          findFirst: {
            args: Prisma.wishListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wishListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>
          }
          findMany: {
            args: Prisma.wishListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>[]
          }
          create: {
            args: Prisma.wishListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>
          }
          createMany: {
            args: Prisma.wishListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wishListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>[]
          }
          delete: {
            args: Prisma.wishListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>
          }
          update: {
            args: Prisma.wishListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>
          }
          deleteMany: {
            args: Prisma.wishListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wishListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wishListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wishListPayload>
          }
          aggregate: {
            args: Prisma.WishListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishList>
          }
          groupBy: {
            args: Prisma.wishListGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishListGroupByOutputType>[]
          }
          count: {
            args: Prisma.wishListCountArgs<ExtArgs>
            result: $Utils.Optional<WishListCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      SeatBed: {
        payload: Prisma.$SeatBedPayload<ExtArgs>
        fields: Prisma.SeatBedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatBedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatBedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>
          }
          findFirst: {
            args: Prisma.SeatBedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatBedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>
          }
          findMany: {
            args: Prisma.SeatBedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>[]
          }
          create: {
            args: Prisma.SeatBedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>
          }
          createMany: {
            args: Prisma.SeatBedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatBedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>[]
          }
          delete: {
            args: Prisma.SeatBedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>
          }
          update: {
            args: Prisma.SeatBedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>
          }
          deleteMany: {
            args: Prisma.SeatBedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatBedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeatBedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatBedPayload>
          }
          aggregate: {
            args: Prisma.SeatBedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatBed>
          }
          groupBy: {
            args: Prisma.SeatBedGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatBedGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatBedCountArgs<ExtArgs>
            result: $Utils.Optional<SeatBedCountAggregateOutputType> | number
          }
        }
      }
      Food: {
        payload: Prisma.$FoodPayload<ExtArgs>
        fields: Prisma.FoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findFirst: {
            args: Prisma.FoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findMany: {
            args: Prisma.FoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          create: {
            args: Prisma.FoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          createMany: {
            args: Prisma.FoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          delete: {
            args: Prisma.FoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          update: {
            args: Prisma.FoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          deleteMany: {
            args: Prisma.FoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          aggregate: {
            args: Prisma.FoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFood>
          }
          groupBy: {
            args: Prisma.FoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      Events: {
        payload: Prisma.$EventsPayload<ExtArgs>
        fields: Prisma.EventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findFirst: {
            args: Prisma.EventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findMany: {
            args: Prisma.EventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          create: {
            args: Prisma.EventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          createMany: {
            args: Prisma.EventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          delete: {
            args: Prisma.EventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          update: {
            args: Prisma.EventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          deleteMany: {
            args: Prisma.EventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Amenities: {
        payload: Prisma.$AmenitiesPayload<ExtArgs>
        fields: Prisma.AmenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findFirst: {
            args: Prisma.AmenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findMany: {
            args: Prisma.AmenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          create: {
            args: Prisma.AmenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          createMany: {
            args: Prisma.AmenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          delete: {
            args: Prisma.AmenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          update: {
            args: Prisma.AmenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          deleteMany: {
            args: Prisma.AmenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          aggregate: {
            args: Prisma.AmenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenities>
          }
          groupBy: {
            args: Prisma.AmenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesCountAggregateOutputType> | number
          }
        }
      }
      Cuisine: {
        payload: Prisma.$CuisinePayload<ExtArgs>
        fields: Prisma.CuisineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CuisineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CuisineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          findFirst: {
            args: Prisma.CuisineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CuisineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          findMany: {
            args: Prisma.CuisineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>[]
          }
          create: {
            args: Prisma.CuisineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          createMany: {
            args: Prisma.CuisineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CuisineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>[]
          }
          delete: {
            args: Prisma.CuisineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          update: {
            args: Prisma.CuisineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          deleteMany: {
            args: Prisma.CuisineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CuisineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CuisineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuisinePayload>
          }
          aggregate: {
            args: Prisma.CuisineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCuisine>
          }
          groupBy: {
            args: Prisma.CuisineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CuisineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CuisineCountArgs<ExtArgs>
            result: $Utils.Optional<CuisineCountAggregateOutputType> | number
          }
        }
      }
      Evbooking: {
        payload: Prisma.$EvbookingPayload<ExtArgs>
        fields: Prisma.EvbookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvbookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvbookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>
          }
          findFirst: {
            args: Prisma.EvbookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvbookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>
          }
          findMany: {
            args: Prisma.EvbookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>[]
          }
          create: {
            args: Prisma.EvbookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>
          }
          createMany: {
            args: Prisma.EvbookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvbookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>[]
          }
          delete: {
            args: Prisma.EvbookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>
          }
          update: {
            args: Prisma.EvbookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>
          }
          deleteMany: {
            args: Prisma.EvbookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvbookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvbookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvbookingPayload>
          }
          aggregate: {
            args: Prisma.EvbookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvbooking>
          }
          groupBy: {
            args: Prisma.EvbookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvbookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvbookingCountArgs<ExtArgs>
            result: $Utils.Optional<EvbookingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.DriverAdapter | null
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OwnerCountOutputType
   */

  export type OwnerCountOutputType = {
    branch: number
    property: number
    booking: number
  }

  export type OwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | OwnerCountOutputTypeCountBranchArgs
    property?: boolean | OwnerCountOutputTypeCountPropertyArgs
    booking?: boolean | OwnerCountOutputTypeCountBookingArgs
  }

  // Custom InputTypes
  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCountOutputType
     */
    select?: OwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    booking: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | UserCountOutputTypeCountBookingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type RolePermissionCountOutputType
   */

  export type RolePermissionCountOutputType = {
    owner: number
  }

  export type RolePermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | RolePermissionCountOutputTypeCountOwnerArgs
  }

  // Custom InputTypes
  /**
   * RolePermissionCountOutputType without action
   */
  export type RolePermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionCountOutputType
     */
    select?: RolePermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolePermissionCountOutputType without action
   */
  export type RolePermissionCountOutputTypeCountOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    tables: number
    seatBed: number
    booking: number
    wishLists: number
    food: number
    branches: number
    event: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | PropertyCountOutputTypeCountTablesArgs
    seatBed?: boolean | PropertyCountOutputTypeCountSeatBedArgs
    booking?: boolean | PropertyCountOutputTypeCountBookingArgs
    wishLists?: boolean | PropertyCountOutputTypeCountWishListsArgs
    food?: boolean | PropertyCountOutputTypeCountFoodArgs
    branches?: boolean | PropertyCountOutputTypeCountBranchesArgs
    event?: boolean | PropertyCountOutputTypeCountEventArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountSeatBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatBedWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountWishListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wishListWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountFoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    booking: number
    events: number
    rolePermission: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BranchCountOutputTypeCountBookingArgs
    events?: boolean | BranchCountOutputTypeCountEventsArgs
    rolePermission?: boolean | BranchCountOutputTypeCountRolePermissionArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountRolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    booking: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | TableCountOutputTypeCountBookingArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type SeatBedCountOutputType
   */

  export type SeatBedCountOutputType = {
    booking: number
  }

  export type SeatBedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | SeatBedCountOutputTypeCountBookingArgs
  }

  // Custom InputTypes
  /**
   * SeatBedCountOutputType without action
   */
  export type SeatBedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBedCountOutputType
     */
    select?: SeatBedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatBedCountOutputType without action
   */
  export type SeatBedCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type EventsCountOutputType
   */

  export type EventsCountOutputType = {
    evbooking: number
  }

  export type EventsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evbooking?: boolean | EventsCountOutputTypeCountEvbookingArgs
  }

  // Custom InputTypes
  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsCountOutputType
     */
    select?: EventsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountEvbookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvbookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payments: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
    loggerType: $Enums.loggerType | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
    loggerType: $Enums.loggerType | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    loggerType: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    loggerType?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    loggerType?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    loggerType?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    sessionToken: string
    userId: number | null
    expires: Date
    loggerType: $Enums.loggerType | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    loggerType?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    loggerType?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    loggerType?: boolean
  }


  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionToken: string
      userId: number | null
      expires: Date
      loggerType: $Enums.loggerType | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly loggerType: FieldRef<"Session", 'loggerType'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
  }


  /**
   * Model Owner
   */

  export type AggregateOwner = {
    _count: OwnerCountAggregateOutputType | null
    _avg: OwnerAvgAggregateOutputType | null
    _sum: OwnerSumAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  export type OwnerAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    roleId: number | null
  }

  export type OwnerSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    roleId: number | null
  }

  export type OwnerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    userType: $Enums.UserType | null
    ownerId: number | null
    roleId: number | null
    birthDate: Date | null
    phoneNumber: string | null
    country: string | null
    city: string | null
    location: string | null
    residenceAddress: string | null
    occupation: string | null
    designation: string | null
    nid: string | null
    tin: string | null
    havingBusiness: boolean | null
    password: string | null
    loggerType: $Enums.loggerType | null
    isVerify: boolean | null
    status: boolean | null
    deletedAtAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OwnerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    userType: $Enums.UserType | null
    ownerId: number | null
    roleId: number | null
    birthDate: Date | null
    phoneNumber: string | null
    country: string | null
    city: string | null
    location: string | null
    residenceAddress: string | null
    occupation: string | null
    designation: string | null
    nid: string | null
    tin: string | null
    havingBusiness: boolean | null
    password: string | null
    loggerType: $Enums.loggerType | null
    isVerify: boolean | null
    status: boolean | null
    deletedAtAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OwnerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    userType: number
    ownerId: number
    roleId: number
    birthDate: number
    phoneNumber: number
    country: number
    city: number
    location: number
    residenceAddress: number
    occupation: number
    designation: number
    nid: number
    tin: number
    havingBusiness: number
    password: number
    loggerType: number
    isVerify: number
    status: number
    deletedAtAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OwnerAvgAggregateInputType = {
    id?: true
    ownerId?: true
    roleId?: true
  }

  export type OwnerSumAggregateInputType = {
    id?: true
    ownerId?: true
    roleId?: true
  }

  export type OwnerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    userType?: true
    ownerId?: true
    roleId?: true
    birthDate?: true
    phoneNumber?: true
    country?: true
    city?: true
    location?: true
    residenceAddress?: true
    occupation?: true
    designation?: true
    nid?: true
    tin?: true
    havingBusiness?: true
    password?: true
    loggerType?: true
    isVerify?: true
    status?: true
    deletedAtAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OwnerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    userType?: true
    ownerId?: true
    roleId?: true
    birthDate?: true
    phoneNumber?: true
    country?: true
    city?: true
    location?: true
    residenceAddress?: true
    occupation?: true
    designation?: true
    nid?: true
    tin?: true
    havingBusiness?: true
    password?: true
    loggerType?: true
    isVerify?: true
    status?: true
    deletedAtAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OwnerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    userType?: true
    ownerId?: true
    roleId?: true
    birthDate?: true
    phoneNumber?: true
    country?: true
    city?: true
    location?: true
    residenceAddress?: true
    occupation?: true
    designation?: true
    nid?: true
    tin?: true
    havingBusiness?: true
    password?: true
    loggerType?: true
    isVerify?: true
    status?: true
    deletedAtAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owner to aggregate.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners
    **/
    _count?: true | OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerMaxAggregateInputType
  }

  export type GetOwnerAggregateType<T extends OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwner[P]>
      : GetScalarType<T[P], AggregateOwner[P]>
  }




  export type OwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithAggregationInput | OwnerOrderByWithAggregationInput[]
    by: OwnerScalarFieldEnum[] | OwnerScalarFieldEnum
    having?: OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCountAggregateInputType | true
    _avg?: OwnerAvgAggregateInputType
    _sum?: OwnerSumAggregateInputType
    _min?: OwnerMinAggregateInputType
    _max?: OwnerMaxAggregateInputType
  }

  export type OwnerGroupByOutputType = {
    id: number
    name: string | null
    email: string | null
    userType: $Enums.UserType | null
    ownerId: number | null
    roleId: number | null
    birthDate: Date | null
    phoneNumber: string | null
    country: string | null
    city: string | null
    location: string | null
    residenceAddress: string | null
    occupation: string | null
    designation: string | null
    nid: string | null
    tin: string | null
    havingBusiness: boolean | null
    password: string | null
    loggerType: $Enums.loggerType | null
    isVerify: boolean
    status: boolean
    deletedAtAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OwnerCountAggregateOutputType | null
    _avg: OwnerAvgAggregateOutputType | null
    _sum: OwnerSumAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  type GetOwnerGroupByPayload<T extends OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerGroupByOutputType[P]>
        }
      >
    >


  export type OwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    userType?: boolean
    ownerId?: boolean
    roleId?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    country?: boolean
    city?: boolean
    location?: boolean
    residenceAddress?: boolean
    occupation?: boolean
    designation?: boolean
    nid?: boolean
    tin?: boolean
    havingBusiness?: boolean
    password?: boolean
    loggerType?: boolean
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Owner$rolesArgs<ExtArgs>
    branch?: boolean | Owner$branchArgs<ExtArgs>
    property?: boolean | Owner$propertyArgs<ExtArgs>
    booking?: boolean | Owner$bookingArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    userType?: boolean
    ownerId?: boolean
    roleId?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    country?: boolean
    city?: boolean
    location?: boolean
    residenceAddress?: boolean
    occupation?: boolean
    designation?: boolean
    nid?: boolean
    tin?: boolean
    havingBusiness?: boolean
    password?: boolean
    loggerType?: boolean
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Owner$rolesArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    userType?: boolean
    ownerId?: boolean
    roleId?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    country?: boolean
    city?: boolean
    location?: boolean
    residenceAddress?: boolean
    occupation?: boolean
    designation?: boolean
    nid?: boolean
    tin?: boolean
    havingBusiness?: boolean
    password?: boolean
    loggerType?: boolean
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Owner$rolesArgs<ExtArgs>
    branch?: boolean | Owner$branchArgs<ExtArgs>
    property?: boolean | Owner$propertyArgs<ExtArgs>
    booking?: boolean | Owner$bookingArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Owner$rolesArgs<ExtArgs>
  }

  export type $OwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owner"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs>[]
      property: Prisma.$PropertyPayload<ExtArgs>[]
      booking: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      email: string | null
      userType: $Enums.UserType | null
      ownerId: number | null
      roleId: number | null
      birthDate: Date | null
      phoneNumber: string | null
      country: string | null
      city: string | null
      location: string | null
      residenceAddress: string | null
      occupation: string | null
      designation: string | null
      nid: string | null
      tin: string | null
      havingBusiness: boolean | null
      password: string | null
      loggerType: $Enums.loggerType | null
      isVerify: boolean
      status: boolean
      deletedAtAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["owner"]>
    composites: {}
  }

  type OwnerGetPayload<S extends boolean | null | undefined | OwnerDefaultArgs> = $Result.GetResult<Prisma.$OwnerPayload, S>

  type OwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerCountAggregateInputType | true
    }

  export interface OwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owner'], meta: { name: 'Owner' } }
    /**
     * Find zero or one Owner that matches the filter.
     * @param {OwnerFindUniqueArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerFindUniqueArgs>(args: SelectSubset<T, OwnerFindUniqueArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Owner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerFindUniqueOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerFindFirstArgs>(args?: SelectSubset<T, OwnerFindFirstArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owner.findMany()
     * 
     * // Get first 10 Owners
     * const owners = await prisma.owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerFindManyArgs>(args?: SelectSubset<T, OwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Owner.
     * @param {OwnerCreateArgs} args - Arguments to create a Owner.
     * @example
     * // Create one Owner
     * const Owner = await prisma.owner.create({
     *   data: {
     *     // ... data to create a Owner
     *   }
     * })
     * 
     */
    create<T extends OwnerCreateArgs>(args: SelectSubset<T, OwnerCreateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Owners.
     * @param {OwnerCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerCreateManyArgs>(args?: SelectSubset<T, OwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Owners and returns the data saved in the database.
     * @param {OwnerCreateManyAndReturnArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Owners and only return the `id`
     * const ownerWithIdOnly = await prisma.owner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Owner.
     * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
     * @example
     * // Delete one Owner
     * const Owner = await prisma.owner.delete({
     *   where: {
     *     // ... filter to delete one Owner
     *   }
     * })
     * 
     */
    delete<T extends OwnerDeleteArgs>(args: SelectSubset<T, OwnerDeleteArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Owner.
     * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
     * @example
     * // Update one Owner
     * const owner = await prisma.owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerUpdateArgs>(args: SelectSubset<T, OwnerUpdateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Owners.
     * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDeleteManyArgs>(args?: SelectSubset<T, OwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerUpdateManyArgs>(args: SelectSubset<T, OwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owner.
     * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
     * @example
     * // Update or create a Owner
     * const owner = await prisma.owner.upsert({
     *   create: {
     *     // ... data to create a Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owner we want to update
     *   }
     * })
     */
    upsert<T extends OwnerUpsertArgs>(args: SelectSubset<T, OwnerUpsertArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owner.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
    **/
    count<T extends OwnerCountArgs>(
      args?: Subset<T, OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerAggregateArgs>(args: Subset<T, OwnerAggregateArgs>): Prisma.PrismaPromise<GetOwnerAggregateType<T>>

    /**
     * Group by Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerGroupByArgs['orderBy'] }
        : { orderBy?: OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owner model
   */
  readonly fields: OwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Owner$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Owner$rolesArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends Owner$branchArgs<ExtArgs> = {}>(args?: Subset<T, Owner$branchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    property<T extends Owner$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Owner$propertyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany"> | Null>
    booking<T extends Owner$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Owner$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owner model
   */ 
  interface OwnerFieldRefs {
    readonly id: FieldRef<"Owner", 'Int'>
    readonly name: FieldRef<"Owner", 'String'>
    readonly email: FieldRef<"Owner", 'String'>
    readonly userType: FieldRef<"Owner", 'UserType'>
    readonly ownerId: FieldRef<"Owner", 'Int'>
    readonly roleId: FieldRef<"Owner", 'Int'>
    readonly birthDate: FieldRef<"Owner", 'DateTime'>
    readonly phoneNumber: FieldRef<"Owner", 'String'>
    readonly country: FieldRef<"Owner", 'String'>
    readonly city: FieldRef<"Owner", 'String'>
    readonly location: FieldRef<"Owner", 'String'>
    readonly residenceAddress: FieldRef<"Owner", 'String'>
    readonly occupation: FieldRef<"Owner", 'String'>
    readonly designation: FieldRef<"Owner", 'String'>
    readonly nid: FieldRef<"Owner", 'String'>
    readonly tin: FieldRef<"Owner", 'String'>
    readonly havingBusiness: FieldRef<"Owner", 'Boolean'>
    readonly password: FieldRef<"Owner", 'String'>
    readonly loggerType: FieldRef<"Owner", 'loggerType'>
    readonly isVerify: FieldRef<"Owner", 'Boolean'>
    readonly status: FieldRef<"Owner", 'Boolean'>
    readonly deletedAtAt: FieldRef<"Owner", 'DateTime'>
    readonly createdAt: FieldRef<"Owner", 'DateTime'>
    readonly updatedAt: FieldRef<"Owner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Owner findUnique
   */
  export type OwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findUniqueOrThrow
   */
  export type OwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findFirst
   */
  export type OwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findFirstOrThrow
   */
  export type OwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findMany
   */
  export type OwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owners to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner create
   */
  export type OwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Owner.
     */
    data: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
  }

  /**
   * Owner createMany
   */
  export type OwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner createManyAndReturn
   */
  export type OwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Owner update
   */
  export type OwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Owner.
     */
    data: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
    /**
     * Choose, which Owner to update.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner updateMany
   */
  export type OwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner upsert
   */
  export type OwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Owner to update in case it exists.
     */
    where: OwnerWhereUniqueInput
    /**
     * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
     */
    create: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
    /**
     * In case the Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
  }

  /**
   * Owner delete
   */
  export type OwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter which Owner to delete.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner deleteMany
   */
  export type OwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners to delete
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner.roles
   */
  export type Owner$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
  }

  /**
   * Owner.branch
   */
  export type Owner$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Owner.property
   */
  export type Owner$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Owner.booking
   */
  export type Owner$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Owner without action
   */
  export type OwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    nid: number | null
    otp: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    nid: number | null
    otp: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    userType: $Enums.UserType | null
    birthDate: Date | null
    phoneNumber: string | null
    picture: string | null
    country: string | null
    city: string | null
    location: string | null
    residenceAddress: string | null
    occupation: string | null
    designation: string | null
    nid: number | null
    tin: string | null
    password: string | null
    otp: number | null
    otpExpireAt: Date | null
    isVerify: boolean | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    userType: $Enums.UserType | null
    birthDate: Date | null
    phoneNumber: string | null
    picture: string | null
    country: string | null
    city: string | null
    location: string | null
    residenceAddress: string | null
    occupation: string | null
    designation: string | null
    nid: number | null
    tin: string | null
    password: string | null
    otp: number | null
    otpExpireAt: Date | null
    isVerify: boolean | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    name: number
    userType: number
    birthDate: number
    phoneNumber: number
    picture: number
    country: number
    city: number
    location: number
    residenceAddress: number
    occupation: number
    designation: number
    nid: number
    tin: number
    password: number
    otp: number
    otpExpireAt: number
    isVerify: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    nid?: true
    otp?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    nid?: true
    otp?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    name?: true
    userType?: true
    birthDate?: true
    phoneNumber?: true
    picture?: true
    country?: true
    city?: true
    location?: true
    residenceAddress?: true
    occupation?: true
    designation?: true
    nid?: true
    tin?: true
    password?: true
    otp?: true
    otpExpireAt?: true
    isVerify?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    name?: true
    userType?: true
    birthDate?: true
    phoneNumber?: true
    picture?: true
    country?: true
    city?: true
    location?: true
    residenceAddress?: true
    occupation?: true
    designation?: true
    nid?: true
    tin?: true
    password?: true
    otp?: true
    otpExpireAt?: true
    isVerify?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    name?: true
    userType?: true
    birthDate?: true
    phoneNumber?: true
    picture?: true
    country?: true
    city?: true
    location?: true
    residenceAddress?: true
    occupation?: true
    designation?: true
    nid?: true
    tin?: true
    password?: true
    otp?: true
    otpExpireAt?: true
    isVerify?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    userType: $Enums.UserType | null
    birthDate: Date | null
    phoneNumber: string | null
    picture: string | null
    country: string | null
    city: string | null
    location: string | null
    residenceAddress: string | null
    occupation: string | null
    designation: string | null
    nid: number | null
    tin: string | null
    password: string | null
    otp: number | null
    otpExpireAt: Date | null
    isVerify: boolean
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userType?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    picture?: boolean
    country?: boolean
    city?: boolean
    location?: boolean
    residenceAddress?: boolean
    occupation?: boolean
    designation?: boolean
    nid?: boolean
    tin?: boolean
    password?: boolean
    otp?: boolean
    otpExpireAt?: boolean
    isVerify?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | User$bookingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userType?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    picture?: boolean
    country?: boolean
    city?: boolean
    location?: boolean
    residenceAddress?: boolean
    occupation?: boolean
    designation?: boolean
    nid?: boolean
    tin?: boolean
    password?: boolean
    otp?: boolean
    otpExpireAt?: boolean
    isVerify?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userType?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    picture?: boolean
    country?: boolean
    city?: boolean
    location?: boolean
    residenceAddress?: boolean
    occupation?: boolean
    designation?: boolean
    nid?: boolean
    tin?: boolean
    password?: boolean
    otp?: boolean
    otpExpireAt?: boolean
    isVerify?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | User$bookingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string | null
      firstName: string | null
      lastName: string | null
      name: string | null
      userType: $Enums.UserType | null
      birthDate: Date | null
      phoneNumber: string | null
      picture: string | null
      country: string | null
      city: string | null
      location: string | null
      residenceAddress: string | null
      occupation: string | null
      designation: string | null
      nid: number | null
      tin: string | null
      password: string | null
      otp: number | null
      otpExpireAt: Date | null
      isVerify: boolean
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends User$bookingArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly picture: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly residenceAddress: FieldRef<"User", 'String'>
    readonly occupation: FieldRef<"User", 'String'>
    readonly designation: FieldRef<"User", 'String'>
    readonly nid: FieldRef<"User", 'Int'>
    readonly tin: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly otp: FieldRef<"User", 'Int'>
    readonly otpExpireAt: FieldRef<"User", 'DateTime'>
    readonly isVerify: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.booking
   */
  export type User$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleName: string | null
    branchId: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleName: string | null
    branchId: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleName: number
    permissions: number
    branchId: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleName?: true
    branchId?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleName?: true
    branchId?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleName?: true
    permissions?: true
    branchId?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleName: string
    permissions: string[]
    branchId: number
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    permissions?: boolean
    branchId?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    owner?: boolean | RolePermission$ownerArgs<ExtArgs>
    _count?: boolean | RolePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    permissions?: boolean
    branchId?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleName?: boolean
    permissions?: boolean
    branchId?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    owner?: boolean | RolePermission$ownerArgs<ExtArgs>
    _count?: boolean | RolePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      owner: Prisma.$OwnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleName: string
      permissions: string[]
      branchId: number
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends RolePermission$ownerArgs<ExtArgs> = {}>(args?: Subset<T, RolePermission$ownerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleName: FieldRef<"RolePermission", 'String'>
    readonly permissions: FieldRef<"RolePermission", 'String[]'>
    readonly branchId: FieldRef<"RolePermission", 'Int'>
    readonly status: FieldRef<"RolePermission", 'Boolean'>
    readonly deletedAt: FieldRef<"RolePermission", 'DateTime'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission.owner
   */
  export type RolePermission$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    cursor?: OwnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model wishList
   */

  export type AggregateWishList = {
    _count: WishListCountAggregateOutputType | null
    _avg: WishListAvgAggregateOutputType | null
    _sum: WishListSumAggregateOutputType | null
    _min: WishListMinAggregateOutputType | null
    _max: WishListMaxAggregateOutputType | null
  }

  export type WishListAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    propertyId: number | null
  }

  export type WishListSumAggregateOutputType = {
    id: number | null
    userId: number | null
    propertyId: number | null
  }

  export type WishListMinAggregateOutputType = {
    id: number | null
    type: $Enums.BusinessCategory | null
    userId: number | null
    propertyId: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishListMaxAggregateOutputType = {
    id: number | null
    type: $Enums.BusinessCategory | null
    userId: number | null
    propertyId: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishListCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    propertyId: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WishListAvgAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
  }

  export type WishListSumAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
  }

  export type WishListMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    propertyId?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishListMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    propertyId?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishListCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    propertyId?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WishListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wishList to aggregate.
     */
    where?: wishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishLists to fetch.
     */
    orderBy?: wishListOrderByWithRelationInput | wishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wishLists
    **/
    _count?: true | WishListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishListMaxAggregateInputType
  }

  export type GetWishListAggregateType<T extends WishListAggregateArgs> = {
        [P in keyof T & keyof AggregateWishList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishList[P]>
      : GetScalarType<T[P], AggregateWishList[P]>
  }




  export type wishListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wishListWhereInput
    orderBy?: wishListOrderByWithAggregationInput | wishListOrderByWithAggregationInput[]
    by: WishListScalarFieldEnum[] | WishListScalarFieldEnum
    having?: wishListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishListCountAggregateInputType | true
    _avg?: WishListAvgAggregateInputType
    _sum?: WishListSumAggregateInputType
    _min?: WishListMinAggregateInputType
    _max?: WishListMaxAggregateInputType
  }

  export type WishListGroupByOutputType = {
    id: number
    type: $Enums.BusinessCategory | null
    userId: number | null
    propertyId: number | null
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WishListCountAggregateOutputType | null
    _avg: WishListAvgAggregateOutputType | null
    _sum: WishListSumAggregateOutputType | null
    _min: WishListMinAggregateOutputType | null
    _max: WishListMaxAggregateOutputType | null
  }

  type GetWishListGroupByPayload<T extends wishListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishListGroupByOutputType[P]>
            : GetScalarType<T[P], WishListGroupByOutputType[P]>
        }
      >
    >


  export type wishListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    propertyId?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | wishList$PropertyArgs<ExtArgs>
  }, ExtArgs["result"]["wishList"]>

  export type wishListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    propertyId?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | wishList$PropertyArgs<ExtArgs>
  }, ExtArgs["result"]["wishList"]>

  export type wishListSelectScalar = {
    id?: boolean
    type?: boolean
    userId?: boolean
    propertyId?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type wishListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | wishList$PropertyArgs<ExtArgs>
  }
  export type wishListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | wishList$PropertyArgs<ExtArgs>
  }

  export type $wishListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wishList"
    objects: {
      Property: Prisma.$PropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.BusinessCategory | null
      userId: number | null
      propertyId: number | null
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wishList"]>
    composites: {}
  }

  type wishListGetPayload<S extends boolean | null | undefined | wishListDefaultArgs> = $Result.GetResult<Prisma.$wishListPayload, S>

  type wishListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<wishListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WishListCountAggregateInputType | true
    }

  export interface wishListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wishList'], meta: { name: 'wishList' } }
    /**
     * Find zero or one WishList that matches the filter.
     * @param {wishListFindUniqueArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wishListFindUniqueArgs>(args: SelectSubset<T, wishListFindUniqueArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WishList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {wishListFindUniqueOrThrowArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wishListFindUniqueOrThrowArgs>(args: SelectSubset<T, wishListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WishList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishListFindFirstArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wishListFindFirstArgs>(args?: SelectSubset<T, wishListFindFirstArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WishList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishListFindFirstOrThrowArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wishListFindFirstOrThrowArgs>(args?: SelectSubset<T, wishListFindFirstOrThrowArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WishLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishLists
     * const wishLists = await prisma.wishList.findMany()
     * 
     * // Get first 10 WishLists
     * const wishLists = await prisma.wishList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishListWithIdOnly = await prisma.wishList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wishListFindManyArgs>(args?: SelectSubset<T, wishListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WishList.
     * @param {wishListCreateArgs} args - Arguments to create a WishList.
     * @example
     * // Create one WishList
     * const WishList = await prisma.wishList.create({
     *   data: {
     *     // ... data to create a WishList
     *   }
     * })
     * 
     */
    create<T extends wishListCreateArgs>(args: SelectSubset<T, wishListCreateArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WishLists.
     * @param {wishListCreateManyArgs} args - Arguments to create many WishLists.
     * @example
     * // Create many WishLists
     * const wishList = await prisma.wishList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wishListCreateManyArgs>(args?: SelectSubset<T, wishListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishLists and returns the data saved in the database.
     * @param {wishListCreateManyAndReturnArgs} args - Arguments to create many WishLists.
     * @example
     * // Create many WishLists
     * const wishList = await prisma.wishList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishLists and only return the `id`
     * const wishListWithIdOnly = await prisma.wishList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wishListCreateManyAndReturnArgs>(args?: SelectSubset<T, wishListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WishList.
     * @param {wishListDeleteArgs} args - Arguments to delete one WishList.
     * @example
     * // Delete one WishList
     * const WishList = await prisma.wishList.delete({
     *   where: {
     *     // ... filter to delete one WishList
     *   }
     * })
     * 
     */
    delete<T extends wishListDeleteArgs>(args: SelectSubset<T, wishListDeleteArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WishList.
     * @param {wishListUpdateArgs} args - Arguments to update one WishList.
     * @example
     * // Update one WishList
     * const wishList = await prisma.wishList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wishListUpdateArgs>(args: SelectSubset<T, wishListUpdateArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WishLists.
     * @param {wishListDeleteManyArgs} args - Arguments to filter WishLists to delete.
     * @example
     * // Delete a few WishLists
     * const { count } = await prisma.wishList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wishListDeleteManyArgs>(args?: SelectSubset<T, wishListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishLists
     * const wishList = await prisma.wishList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wishListUpdateManyArgs>(args: SelectSubset<T, wishListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WishList.
     * @param {wishListUpsertArgs} args - Arguments to update or create a WishList.
     * @example
     * // Update or create a WishList
     * const wishList = await prisma.wishList.upsert({
     *   create: {
     *     // ... data to create a WishList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishList we want to update
     *   }
     * })
     */
    upsert<T extends wishListUpsertArgs>(args: SelectSubset<T, wishListUpsertArgs<ExtArgs>>): Prisma__wishListClient<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WishLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishListCountArgs} args - Arguments to filter WishLists to count.
     * @example
     * // Count the number of WishLists
     * const count = await prisma.wishList.count({
     *   where: {
     *     // ... the filter for the WishLists we want to count
     *   }
     * })
    **/
    count<T extends wishListCountArgs>(
      args?: Subset<T, wishListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishListAggregateArgs>(args: Subset<T, WishListAggregateArgs>): Prisma.PrismaPromise<GetWishListAggregateType<T>>

    /**
     * Group by WishList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wishListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wishListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wishListGroupByArgs['orderBy'] }
        : { orderBy?: wishListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wishListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wishList model
   */
  readonly fields: wishListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wishList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wishListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Property<T extends wishList$PropertyArgs<ExtArgs> = {}>(args?: Subset<T, wishList$PropertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wishList model
   */ 
  interface wishListFieldRefs {
    readonly id: FieldRef<"wishList", 'Int'>
    readonly type: FieldRef<"wishList", 'BusinessCategory'>
    readonly userId: FieldRef<"wishList", 'Int'>
    readonly propertyId: FieldRef<"wishList", 'Int'>
    readonly status: FieldRef<"wishList", 'Boolean'>
    readonly deletedAt: FieldRef<"wishList", 'DateTime'>
    readonly createdAt: FieldRef<"wishList", 'DateTime'>
    readonly updatedAt: FieldRef<"wishList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wishList findUnique
   */
  export type wishListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * Filter, which wishList to fetch.
     */
    where: wishListWhereUniqueInput
  }

  /**
   * wishList findUniqueOrThrow
   */
  export type wishListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * Filter, which wishList to fetch.
     */
    where: wishListWhereUniqueInput
  }

  /**
   * wishList findFirst
   */
  export type wishListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * Filter, which wishList to fetch.
     */
    where?: wishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishLists to fetch.
     */
    orderBy?: wishListOrderByWithRelationInput | wishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wishLists.
     */
    cursor?: wishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wishLists.
     */
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * wishList findFirstOrThrow
   */
  export type wishListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * Filter, which wishList to fetch.
     */
    where?: wishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishLists to fetch.
     */
    orderBy?: wishListOrderByWithRelationInput | wishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wishLists.
     */
    cursor?: wishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wishLists.
     */
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * wishList findMany
   */
  export type wishListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * Filter, which wishLists to fetch.
     */
    where?: wishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wishLists to fetch.
     */
    orderBy?: wishListOrderByWithRelationInput | wishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wishLists.
     */
    cursor?: wishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wishLists.
     */
    skip?: number
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * wishList create
   */
  export type wishListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * The data needed to create a wishList.
     */
    data: XOR<wishListCreateInput, wishListUncheckedCreateInput>
  }

  /**
   * wishList createMany
   */
  export type wishListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wishLists.
     */
    data: wishListCreateManyInput | wishListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wishList createManyAndReturn
   */
  export type wishListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many wishLists.
     */
    data: wishListCreateManyInput | wishListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wishList update
   */
  export type wishListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * The data needed to update a wishList.
     */
    data: XOR<wishListUpdateInput, wishListUncheckedUpdateInput>
    /**
     * Choose, which wishList to update.
     */
    where: wishListWhereUniqueInput
  }

  /**
   * wishList updateMany
   */
  export type wishListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wishLists.
     */
    data: XOR<wishListUpdateManyMutationInput, wishListUncheckedUpdateManyInput>
    /**
     * Filter which wishLists to update
     */
    where?: wishListWhereInput
  }

  /**
   * wishList upsert
   */
  export type wishListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * The filter to search for the wishList to update in case it exists.
     */
    where: wishListWhereUniqueInput
    /**
     * In case the wishList found by the `where` argument doesn't exist, create a new wishList with this data.
     */
    create: XOR<wishListCreateInput, wishListUncheckedCreateInput>
    /**
     * In case the wishList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wishListUpdateInput, wishListUncheckedUpdateInput>
  }

  /**
   * wishList delete
   */
  export type wishListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    /**
     * Filter which wishList to delete.
     */
    where: wishListWhereUniqueInput
  }

  /**
   * wishList deleteMany
   */
  export type wishListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wishLists to delete
     */
    where?: wishListWhereInput
  }

  /**
   * wishList.Property
   */
  export type wishList$PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * wishList without action
   */
  export type wishListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    sectSymb: number | null
    priority: number | null
  }

  export type PropertySumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    sectSymb: number | null
    priority: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: number | null
    ownerId: number | null
    type: $Enums.BusinessCategory | null
    listingName: string | null
    slug: string | null
    title: string | null
    subTitle: string | null
    logo: string | null
    description: string | null
    terms: string | null
    reservationCategory: $Enums.Category | null
    sectSymb: number | null
    priority: number | null
    eventStatus: boolean | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: number | null
    ownerId: number | null
    type: $Enums.BusinessCategory | null
    listingName: string | null
    slug: string | null
    title: string | null
    subTitle: string | null
    logo: string | null
    description: string | null
    terms: string | null
    reservationCategory: $Enums.Category | null
    sectSymb: number | null
    priority: number | null
    eventStatus: boolean | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    ownerId: number
    type: number
    listingName: number
    slug: number
    title: number
    subTitle: number
    logo: number
    image: number
    description: number
    terms: number
    slot: number
    offday: number
    cuisines: number
    reservationCategory: number
    sectSymb: number
    priority: number
    optionalData: number
    eventStatus: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    id?: true
    ownerId?: true
    sectSymb?: true
    priority?: true
  }

  export type PropertySumAggregateInputType = {
    id?: true
    ownerId?: true
    sectSymb?: true
    priority?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    ownerId?: true
    type?: true
    listingName?: true
    slug?: true
    title?: true
    subTitle?: true
    logo?: true
    description?: true
    terms?: true
    reservationCategory?: true
    sectSymb?: true
    priority?: true
    eventStatus?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    ownerId?: true
    type?: true
    listingName?: true
    slug?: true
    title?: true
    subTitle?: true
    logo?: true
    description?: true
    terms?: true
    reservationCategory?: true
    sectSymb?: true
    priority?: true
    eventStatus?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    ownerId?: true
    type?: true
    listingName?: true
    slug?: true
    title?: true
    subTitle?: true
    logo?: true
    image?: true
    description?: true
    terms?: true
    slot?: true
    offday?: true
    cuisines?: true
    reservationCategory?: true
    sectSymb?: true
    priority?: true
    optionalData?: true
    eventStatus?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: number
    ownerId: number
    type: $Enums.BusinessCategory | null
    listingName: string
    slug: string | null
    title: string | null
    subTitle: string | null
    logo: string | null
    image: JsonValue | null
    description: string | null
    terms: string | null
    slot: JsonValue | null
    offday: JsonValue | null
    cuisines: string[]
    reservationCategory: $Enums.Category | null
    sectSymb: number | null
    priority: number | null
    optionalData: JsonValue | null
    eventStatus: boolean
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    type?: boolean
    listingName?: boolean
    slug?: boolean
    title?: boolean
    subTitle?: boolean
    logo?: boolean
    image?: boolean
    description?: boolean
    terms?: boolean
    slot?: boolean
    offday?: boolean
    cuisines?: boolean
    reservationCategory?: boolean
    sectSymb?: boolean
    priority?: boolean
    optionalData?: boolean
    eventStatus?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    tables?: boolean | Property$tablesArgs<ExtArgs>
    seatBed?: boolean | Property$seatBedArgs<ExtArgs>
    booking?: boolean | Property$bookingArgs<ExtArgs>
    wishLists?: boolean | Property$wishListsArgs<ExtArgs>
    food?: boolean | Property$foodArgs<ExtArgs>
    branches?: boolean | Property$branchesArgs<ExtArgs>
    event?: boolean | Property$eventArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    type?: boolean
    listingName?: boolean
    slug?: boolean
    title?: boolean
    subTitle?: boolean
    logo?: boolean
    image?: boolean
    description?: boolean
    terms?: boolean
    slot?: boolean
    offday?: boolean
    cuisines?: boolean
    reservationCategory?: boolean
    sectSymb?: boolean
    priority?: boolean
    optionalData?: boolean
    eventStatus?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    ownerId?: boolean
    type?: boolean
    listingName?: boolean
    slug?: boolean
    title?: boolean
    subTitle?: boolean
    logo?: boolean
    image?: boolean
    description?: boolean
    terms?: boolean
    slot?: boolean
    offday?: boolean
    cuisines?: boolean
    reservationCategory?: boolean
    sectSymb?: boolean
    priority?: boolean
    optionalData?: boolean
    eventStatus?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    tables?: boolean | Property$tablesArgs<ExtArgs>
    seatBed?: boolean | Property$seatBedArgs<ExtArgs>
    booking?: boolean | Property$bookingArgs<ExtArgs>
    wishLists?: boolean | Property$wishListsArgs<ExtArgs>
    food?: boolean | Property$foodArgs<ExtArgs>
    branches?: boolean | Property$branchesArgs<ExtArgs>
    event?: boolean | Property$eventArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      owner: Prisma.$OwnerPayload<ExtArgs>
      tables: Prisma.$TablePayload<ExtArgs>[]
      seatBed: Prisma.$SeatBedPayload<ExtArgs>[]
      booking: Prisma.$BookingPayload<ExtArgs>[]
      wishLists: Prisma.$wishListPayload<ExtArgs>[]
      food: Prisma.$FoodPayload<ExtArgs>[]
      branches: Prisma.$BranchPayload<ExtArgs>[]
      event: Prisma.$EventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ownerId: number
      type: $Enums.BusinessCategory | null
      listingName: string
      slug: string | null
      title: string | null
      subTitle: string | null
      logo: string | null
      image: Prisma.JsonValue | null
      description: string | null
      terms: string | null
      slot: Prisma.JsonValue | null
      offday: Prisma.JsonValue | null
      cuisines: string[]
      reservationCategory: $Enums.Category | null
      sectSymb: number | null
      priority: number | null
      optionalData: Prisma.JsonValue | null
      eventStatus: boolean
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tables<T extends Property$tablesArgs<ExtArgs> = {}>(args?: Subset<T, Property$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany"> | Null>
    seatBed<T extends Property$seatBedArgs<ExtArgs> = {}>(args?: Subset<T, Property$seatBedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findMany"> | Null>
    booking<T extends Property$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Property$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    wishLists<T extends Property$wishListsArgs<ExtArgs> = {}>(args?: Subset<T, Property$wishListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wishListPayload<ExtArgs>, T, "findMany"> | Null>
    food<T extends Property$foodArgs<ExtArgs> = {}>(args?: Subset<T, Property$foodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany"> | Null>
    branches<T extends Property$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Property$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    event<T extends Property$eventArgs<ExtArgs> = {}>(args?: Subset<T, Property$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */ 
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'Int'>
    readonly ownerId: FieldRef<"Property", 'Int'>
    readonly type: FieldRef<"Property", 'BusinessCategory'>
    readonly listingName: FieldRef<"Property", 'String'>
    readonly slug: FieldRef<"Property", 'String'>
    readonly title: FieldRef<"Property", 'String'>
    readonly subTitle: FieldRef<"Property", 'String'>
    readonly logo: FieldRef<"Property", 'String'>
    readonly image: FieldRef<"Property", 'Json'>
    readonly description: FieldRef<"Property", 'String'>
    readonly terms: FieldRef<"Property", 'String'>
    readonly slot: FieldRef<"Property", 'Json'>
    readonly offday: FieldRef<"Property", 'Json'>
    readonly cuisines: FieldRef<"Property", 'String[]'>
    readonly reservationCategory: FieldRef<"Property", 'Category'>
    readonly sectSymb: FieldRef<"Property", 'Int'>
    readonly priority: FieldRef<"Property", 'Int'>
    readonly optionalData: FieldRef<"Property", 'Json'>
    readonly eventStatus: FieldRef<"Property", 'Boolean'>
    readonly status: FieldRef<"Property", 'Boolean'>
    readonly deletedAt: FieldRef<"Property", 'DateTime'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
  }

  /**
   * Property.tables
   */
  export type Property$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Property.seatBed
   */
  export type Property$seatBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    where?: SeatBedWhereInput
    orderBy?: SeatBedOrderByWithRelationInput | SeatBedOrderByWithRelationInput[]
    cursor?: SeatBedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatBedScalarFieldEnum | SeatBedScalarFieldEnum[]
  }

  /**
   * Property.booking
   */
  export type Property$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Property.wishLists
   */
  export type Property$wishListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wishList
     */
    select?: wishListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wishListInclude<ExtArgs> | null
    where?: wishListWhereInput
    orderBy?: wishListOrderByWithRelationInput | wishListOrderByWithRelationInput[]
    cursor?: wishListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * Property.food
   */
  export type Property$foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    cursor?: FoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Property.branches
   */
  export type Property$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Property.event
   */
  export type Property$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    propertyId: number | null
    bookingCount: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    propertyId: number | null
    bookingCount: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    ownerId: number | null
    propertyId: number | null
    branchName: string | null
    slug: string | null
    description: string | null
    level: string | null
    terms: string | null
    city: string | null
    area: string | null
    country: string | null
    latitude: string | null
    longitude: string | null
    location: string | null
    bookingCount: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    ownerId: number | null
    propertyId: number | null
    branchName: string | null
    slug: string | null
    description: string | null
    level: string | null
    terms: string | null
    city: string | null
    area: string | null
    country: string | null
    latitude: string | null
    longitude: string | null
    location: string | null
    bookingCount: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    ownerId: number
    propertyId: number
    branchName: number
    slug: number
    images: number
    description: number
    level: number
    terms: number
    city: number
    area: number
    country: number
    amenities: number
    amenity: number
    latitude: number
    longitude: number
    location: number
    optionalData: number
    bookingCount: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
    ownerId?: true
    propertyId?: true
    bookingCount?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
    ownerId?: true
    propertyId?: true
    bookingCount?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    ownerId?: true
    propertyId?: true
    branchName?: true
    slug?: true
    description?: true
    level?: true
    terms?: true
    city?: true
    area?: true
    country?: true
    latitude?: true
    longitude?: true
    location?: true
    bookingCount?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    ownerId?: true
    propertyId?: true
    branchName?: true
    slug?: true
    description?: true
    level?: true
    terms?: true
    city?: true
    area?: true
    country?: true
    latitude?: true
    longitude?: true
    location?: true
    bookingCount?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    ownerId?: true
    propertyId?: true
    branchName?: true
    slug?: true
    images?: true
    description?: true
    level?: true
    terms?: true
    city?: true
    area?: true
    country?: true
    amenities?: true
    amenity?: true
    latitude?: true
    longitude?: true
    location?: true
    optionalData?: true
    bookingCount?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    ownerId: number
    propertyId: number
    branchName: string | null
    slug: string | null
    images: JsonValue | null
    description: string | null
    level: string | null
    terms: string | null
    city: string | null
    area: string | null
    country: string | null
    amenities: JsonValue | null
    amenity: string[]
    latitude: string | null
    longitude: string | null
    location: string | null
    optionalData: JsonValue | null
    bookingCount: number
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    propertyId?: boolean
    branchName?: boolean
    slug?: boolean
    images?: boolean
    description?: boolean
    level?: boolean
    terms?: boolean
    city?: boolean
    area?: boolean
    country?: boolean
    amenities?: boolean
    amenity?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    optionalData?: boolean
    bookingCount?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | Branch$bookingArgs<ExtArgs>
    events?: boolean | Branch$eventsArgs<ExtArgs>
    rolePermission?: boolean | Branch$rolePermissionArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    propertyId?: boolean
    branchName?: boolean
    slug?: boolean
    images?: boolean
    description?: boolean
    level?: boolean
    terms?: boolean
    city?: boolean
    area?: boolean
    country?: boolean
    amenities?: boolean
    amenity?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    optionalData?: boolean
    bookingCount?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    ownerId?: boolean
    propertyId?: boolean
    branchName?: boolean
    slug?: boolean
    images?: boolean
    description?: boolean
    level?: boolean
    terms?: boolean
    city?: boolean
    area?: boolean
    country?: boolean
    amenities?: boolean
    amenity?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    optionalData?: boolean
    bookingCount?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | Branch$bookingArgs<ExtArgs>
    events?: boolean | Branch$eventsArgs<ExtArgs>
    rolePermission?: boolean | Branch$rolePermissionArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      owner: Prisma.$OwnerPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>[]
      events: Prisma.$EventsPayload<ExtArgs>[]
      rolePermission: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ownerId: number
      propertyId: number
      branchName: string | null
      slug: string | null
      images: Prisma.JsonValue | null
      description: string | null
      level: string | null
      terms: string | null
      city: string | null
      area: string | null
      country: string | null
      amenities: Prisma.JsonValue | null
      amenity: string[]
      latitude: string | null
      longitude: string | null
      location: string | null
      optionalData: Prisma.JsonValue | null
      bookingCount: number
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    booking<T extends Branch$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Branch$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Branch$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany"> | Null>
    rolePermission<T extends Branch$rolePermissionArgs<ExtArgs> = {}>(args?: Subset<T, Branch$rolePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly ownerId: FieldRef<"Branch", 'Int'>
    readonly propertyId: FieldRef<"Branch", 'Int'>
    readonly branchName: FieldRef<"Branch", 'String'>
    readonly slug: FieldRef<"Branch", 'String'>
    readonly images: FieldRef<"Branch", 'Json'>
    readonly description: FieldRef<"Branch", 'String'>
    readonly level: FieldRef<"Branch", 'String'>
    readonly terms: FieldRef<"Branch", 'String'>
    readonly city: FieldRef<"Branch", 'String'>
    readonly area: FieldRef<"Branch", 'String'>
    readonly country: FieldRef<"Branch", 'String'>
    readonly amenities: FieldRef<"Branch", 'Json'>
    readonly amenity: FieldRef<"Branch", 'String[]'>
    readonly latitude: FieldRef<"Branch", 'String'>
    readonly longitude: FieldRef<"Branch", 'String'>
    readonly location: FieldRef<"Branch", 'String'>
    readonly optionalData: FieldRef<"Branch", 'Json'>
    readonly bookingCount: FieldRef<"Branch", 'Int'>
    readonly status: FieldRef<"Branch", 'Boolean'>
    readonly deletedAt: FieldRef<"Branch", 'DateTime'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.booking
   */
  export type Branch$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Branch.events
   */
  export type Branch$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Branch.rolePermission
   */
  export type Branch$rolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    capacity: number | null
  }

  export type TableSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    capacity: number | null
  }

  export type TableMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    type: $Enums.compType | null
    capacity: number | null
    position: string | null
    size: string | null
    image: string | null
    splitable: boolean | null
    ryservable: boolean | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    type: $Enums.compType | null
    capacity: number | null
    position: string | null
    size: string | null
    image: string | null
    splitable: boolean | null
    ryservable: boolean | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    propertyId: number
    type: number
    capacity: number
    position: number
    size: number
    image: number
    splitable: number
    ryservable: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    id?: true
    propertyId?: true
    capacity?: true
  }

  export type TableSumAggregateInputType = {
    id?: true
    propertyId?: true
    capacity?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    capacity?: true
    position?: true
    size?: true
    image?: true
    splitable?: true
    ryservable?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    capacity?: true
    position?: true
    size?: true
    image?: true
    splitable?: true
    ryservable?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    capacity?: true
    position?: true
    size?: true
    image?: true
    splitable?: true
    ryservable?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: number
    propertyId: number
    type: $Enums.compType | null
    capacity: number | null
    position: string
    size: string
    image: string | null
    splitable: boolean
    ryservable: boolean
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    capacity?: boolean
    position?: boolean
    size?: boolean
    image?: boolean
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | Table$bookingArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    capacity?: boolean
    position?: boolean
    size?: boolean
    image?: boolean
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectScalar = {
    id?: boolean
    propertyId?: boolean
    type?: boolean
    capacity?: boolean
    position?: boolean
    size?: boolean
    image?: boolean
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | Table$bookingArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      Property: Prisma.$PropertyPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      type: $Enums.compType | null
      capacity: number | null
      position: string
      size: string
      image: string | null
      splitable: boolean
      ryservable: boolean
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tables and returns the data saved in the database.
     * @param {TableCreateManyAndReturnArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableCreateManyAndReturnArgs>(args?: SelectSubset<T, TableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    booking<T extends Table$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Table$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */ 
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'Int'>
    readonly propertyId: FieldRef<"Table", 'Int'>
    readonly type: FieldRef<"Table", 'compType'>
    readonly capacity: FieldRef<"Table", 'Int'>
    readonly position: FieldRef<"Table", 'String'>
    readonly size: FieldRef<"Table", 'String'>
    readonly image: FieldRef<"Table", 'String'>
    readonly splitable: FieldRef<"Table", 'Boolean'>
    readonly ryservable: FieldRef<"Table", 'Boolean'>
    readonly status: FieldRef<"Table", 'Boolean'>
    readonly deletedAt: FieldRef<"Table", 'DateTime'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Table createManyAndReturn
   */
  export type TableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
  }

  /**
   * Table.booking
   */
  export type Table$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model SeatBed
   */

  export type AggregateSeatBed = {
    _count: SeatBedCountAggregateOutputType | null
    _avg: SeatBedAvgAggregateOutputType | null
    _sum: SeatBedSumAggregateOutputType | null
    _min: SeatBedMinAggregateOutputType | null
    _max: SeatBedMaxAggregateOutputType | null
  }

  export type SeatBedAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
  }

  export type SeatBedSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
  }

  export type SeatBedMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    type: $Enums.compType | null
    roomNo: string | null
    breakfast: string | null
    image: string | null
    accomodationCapacity: string | null
    extraBedPolicy: string | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatBedMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    type: $Enums.compType | null
    roomNo: string | null
    breakfast: string | null
    image: string | null
    accomodationCapacity: string | null
    extraBedPolicy: string | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatBedCountAggregateOutputType = {
    id: number
    propertyId: number
    type: number
    roomNo: number
    breakfast: number
    image: number
    accomodationCapacity: number
    extraBedPolicy: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeatBedAvgAggregateInputType = {
    id?: true
    propertyId?: true
  }

  export type SeatBedSumAggregateInputType = {
    id?: true
    propertyId?: true
  }

  export type SeatBedMinAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    roomNo?: true
    breakfast?: true
    image?: true
    accomodationCapacity?: true
    extraBedPolicy?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatBedMaxAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    roomNo?: true
    breakfast?: true
    image?: true
    accomodationCapacity?: true
    extraBedPolicy?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatBedCountAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    roomNo?: true
    breakfast?: true
    image?: true
    accomodationCapacity?: true
    extraBedPolicy?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeatBedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatBed to aggregate.
     */
    where?: SeatBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatBeds to fetch.
     */
    orderBy?: SeatBedOrderByWithRelationInput | SeatBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatBeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeatBeds
    **/
    _count?: true | SeatBedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatBedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatBedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatBedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatBedMaxAggregateInputType
  }

  export type GetSeatBedAggregateType<T extends SeatBedAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatBed[P]>
      : GetScalarType<T[P], AggregateSeatBed[P]>
  }




  export type SeatBedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatBedWhereInput
    orderBy?: SeatBedOrderByWithAggregationInput | SeatBedOrderByWithAggregationInput[]
    by: SeatBedScalarFieldEnum[] | SeatBedScalarFieldEnum
    having?: SeatBedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatBedCountAggregateInputType | true
    _avg?: SeatBedAvgAggregateInputType
    _sum?: SeatBedSumAggregateInputType
    _min?: SeatBedMinAggregateInputType
    _max?: SeatBedMaxAggregateInputType
  }

  export type SeatBedGroupByOutputType = {
    id: number
    propertyId: number
    type: $Enums.compType | null
    roomNo: string
    breakfast: string
    image: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SeatBedCountAggregateOutputType | null
    _avg: SeatBedAvgAggregateOutputType | null
    _sum: SeatBedSumAggregateOutputType | null
    _min: SeatBedMinAggregateOutputType | null
    _max: SeatBedMaxAggregateOutputType | null
  }

  type GetSeatBedGroupByPayload<T extends SeatBedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatBedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatBedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatBedGroupByOutputType[P]>
            : GetScalarType<T[P], SeatBedGroupByOutputType[P]>
        }
      >
    >


  export type SeatBedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    roomNo?: boolean
    breakfast?: boolean
    image?: boolean
    accomodationCapacity?: boolean
    extraBedPolicy?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | SeatBed$bookingArgs<ExtArgs>
    _count?: boolean | SeatBedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatBed"]>

  export type SeatBedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    roomNo?: boolean
    breakfast?: boolean
    image?: boolean
    accomodationCapacity?: boolean
    extraBedPolicy?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatBed"]>

  export type SeatBedSelectScalar = {
    id?: boolean
    propertyId?: boolean
    type?: boolean
    roomNo?: boolean
    breakfast?: boolean
    image?: boolean
    accomodationCapacity?: boolean
    extraBedPolicy?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeatBedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | SeatBed$bookingArgs<ExtArgs>
    _count?: boolean | SeatBedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatBedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $SeatBedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeatBed"
    objects: {
      Property: Prisma.$PropertyPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      type: $Enums.compType | null
      roomNo: string
      breakfast: string
      image: string | null
      accomodationCapacity: string
      extraBedPolicy: string
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seatBed"]>
    composites: {}
  }

  type SeatBedGetPayload<S extends boolean | null | undefined | SeatBedDefaultArgs> = $Result.GetResult<Prisma.$SeatBedPayload, S>

  type SeatBedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeatBedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeatBedCountAggregateInputType | true
    }

  export interface SeatBedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeatBed'], meta: { name: 'SeatBed' } }
    /**
     * Find zero or one SeatBed that matches the filter.
     * @param {SeatBedFindUniqueArgs} args - Arguments to find a SeatBed
     * @example
     * // Get one SeatBed
     * const seatBed = await prisma.seatBed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatBedFindUniqueArgs>(args: SelectSubset<T, SeatBedFindUniqueArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeatBed that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeatBedFindUniqueOrThrowArgs} args - Arguments to find a SeatBed
     * @example
     * // Get one SeatBed
     * const seatBed = await prisma.seatBed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatBedFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatBedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeatBed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedFindFirstArgs} args - Arguments to find a SeatBed
     * @example
     * // Get one SeatBed
     * const seatBed = await prisma.seatBed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatBedFindFirstArgs>(args?: SelectSubset<T, SeatBedFindFirstArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeatBed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedFindFirstOrThrowArgs} args - Arguments to find a SeatBed
     * @example
     * // Get one SeatBed
     * const seatBed = await prisma.seatBed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatBedFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatBedFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeatBeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeatBeds
     * const seatBeds = await prisma.seatBed.findMany()
     * 
     * // Get first 10 SeatBeds
     * const seatBeds = await prisma.seatBed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatBedWithIdOnly = await prisma.seatBed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatBedFindManyArgs>(args?: SelectSubset<T, SeatBedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeatBed.
     * @param {SeatBedCreateArgs} args - Arguments to create a SeatBed.
     * @example
     * // Create one SeatBed
     * const SeatBed = await prisma.seatBed.create({
     *   data: {
     *     // ... data to create a SeatBed
     *   }
     * })
     * 
     */
    create<T extends SeatBedCreateArgs>(args: SelectSubset<T, SeatBedCreateArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeatBeds.
     * @param {SeatBedCreateManyArgs} args - Arguments to create many SeatBeds.
     * @example
     * // Create many SeatBeds
     * const seatBed = await prisma.seatBed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatBedCreateManyArgs>(args?: SelectSubset<T, SeatBedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeatBeds and returns the data saved in the database.
     * @param {SeatBedCreateManyAndReturnArgs} args - Arguments to create many SeatBeds.
     * @example
     * // Create many SeatBeds
     * const seatBed = await prisma.seatBed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeatBeds and only return the `id`
     * const seatBedWithIdOnly = await prisma.seatBed.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatBedCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatBedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeatBed.
     * @param {SeatBedDeleteArgs} args - Arguments to delete one SeatBed.
     * @example
     * // Delete one SeatBed
     * const SeatBed = await prisma.seatBed.delete({
     *   where: {
     *     // ... filter to delete one SeatBed
     *   }
     * })
     * 
     */
    delete<T extends SeatBedDeleteArgs>(args: SelectSubset<T, SeatBedDeleteArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeatBed.
     * @param {SeatBedUpdateArgs} args - Arguments to update one SeatBed.
     * @example
     * // Update one SeatBed
     * const seatBed = await prisma.seatBed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatBedUpdateArgs>(args: SelectSubset<T, SeatBedUpdateArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeatBeds.
     * @param {SeatBedDeleteManyArgs} args - Arguments to filter SeatBeds to delete.
     * @example
     * // Delete a few SeatBeds
     * const { count } = await prisma.seatBed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatBedDeleteManyArgs>(args?: SelectSubset<T, SeatBedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatBeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeatBeds
     * const seatBed = await prisma.seatBed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatBedUpdateManyArgs>(args: SelectSubset<T, SeatBedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeatBed.
     * @param {SeatBedUpsertArgs} args - Arguments to update or create a SeatBed.
     * @example
     * // Update or create a SeatBed
     * const seatBed = await prisma.seatBed.upsert({
     *   create: {
     *     // ... data to create a SeatBed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeatBed we want to update
     *   }
     * })
     */
    upsert<T extends SeatBedUpsertArgs>(args: SelectSubset<T, SeatBedUpsertArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeatBeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedCountArgs} args - Arguments to filter SeatBeds to count.
     * @example
     * // Count the number of SeatBeds
     * const count = await prisma.seatBed.count({
     *   where: {
     *     // ... the filter for the SeatBeds we want to count
     *   }
     * })
    **/
    count<T extends SeatBedCountArgs>(
      args?: Subset<T, SeatBedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatBedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeatBed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatBedAggregateArgs>(args: Subset<T, SeatBedAggregateArgs>): Prisma.PrismaPromise<GetSeatBedAggregateType<T>>

    /**
     * Group by SeatBed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatBedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatBedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatBedGroupByArgs['orderBy'] }
        : { orderBy?: SeatBedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatBedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeatBed model
   */
  readonly fields: SeatBedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeatBed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatBedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    booking<T extends SeatBed$bookingArgs<ExtArgs> = {}>(args?: Subset<T, SeatBed$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeatBed model
   */ 
  interface SeatBedFieldRefs {
    readonly id: FieldRef<"SeatBed", 'Int'>
    readonly propertyId: FieldRef<"SeatBed", 'Int'>
    readonly type: FieldRef<"SeatBed", 'compType'>
    readonly roomNo: FieldRef<"SeatBed", 'String'>
    readonly breakfast: FieldRef<"SeatBed", 'String'>
    readonly image: FieldRef<"SeatBed", 'String'>
    readonly accomodationCapacity: FieldRef<"SeatBed", 'String'>
    readonly extraBedPolicy: FieldRef<"SeatBed", 'String'>
    readonly status: FieldRef<"SeatBed", 'Boolean'>
    readonly deletedAt: FieldRef<"SeatBed", 'DateTime'>
    readonly createdAt: FieldRef<"SeatBed", 'DateTime'>
    readonly updatedAt: FieldRef<"SeatBed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeatBed findUnique
   */
  export type SeatBedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * Filter, which SeatBed to fetch.
     */
    where: SeatBedWhereUniqueInput
  }

  /**
   * SeatBed findUniqueOrThrow
   */
  export type SeatBedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * Filter, which SeatBed to fetch.
     */
    where: SeatBedWhereUniqueInput
  }

  /**
   * SeatBed findFirst
   */
  export type SeatBedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * Filter, which SeatBed to fetch.
     */
    where?: SeatBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatBeds to fetch.
     */
    orderBy?: SeatBedOrderByWithRelationInput | SeatBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatBeds.
     */
    cursor?: SeatBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatBeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatBeds.
     */
    distinct?: SeatBedScalarFieldEnum | SeatBedScalarFieldEnum[]
  }

  /**
   * SeatBed findFirstOrThrow
   */
  export type SeatBedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * Filter, which SeatBed to fetch.
     */
    where?: SeatBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatBeds to fetch.
     */
    orderBy?: SeatBedOrderByWithRelationInput | SeatBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatBeds.
     */
    cursor?: SeatBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatBeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatBeds.
     */
    distinct?: SeatBedScalarFieldEnum | SeatBedScalarFieldEnum[]
  }

  /**
   * SeatBed findMany
   */
  export type SeatBedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * Filter, which SeatBeds to fetch.
     */
    where?: SeatBedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatBeds to fetch.
     */
    orderBy?: SeatBedOrderByWithRelationInput | SeatBedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeatBeds.
     */
    cursor?: SeatBedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatBeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatBeds.
     */
    skip?: number
    distinct?: SeatBedScalarFieldEnum | SeatBedScalarFieldEnum[]
  }

  /**
   * SeatBed create
   */
  export type SeatBedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * The data needed to create a SeatBed.
     */
    data: XOR<SeatBedCreateInput, SeatBedUncheckedCreateInput>
  }

  /**
   * SeatBed createMany
   */
  export type SeatBedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeatBeds.
     */
    data: SeatBedCreateManyInput | SeatBedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeatBed createManyAndReturn
   */
  export type SeatBedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeatBeds.
     */
    data: SeatBedCreateManyInput | SeatBedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatBed update
   */
  export type SeatBedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * The data needed to update a SeatBed.
     */
    data: XOR<SeatBedUpdateInput, SeatBedUncheckedUpdateInput>
    /**
     * Choose, which SeatBed to update.
     */
    where: SeatBedWhereUniqueInput
  }

  /**
   * SeatBed updateMany
   */
  export type SeatBedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeatBeds.
     */
    data: XOR<SeatBedUpdateManyMutationInput, SeatBedUncheckedUpdateManyInput>
    /**
     * Filter which SeatBeds to update
     */
    where?: SeatBedWhereInput
  }

  /**
   * SeatBed upsert
   */
  export type SeatBedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * The filter to search for the SeatBed to update in case it exists.
     */
    where: SeatBedWhereUniqueInput
    /**
     * In case the SeatBed found by the `where` argument doesn't exist, create a new SeatBed with this data.
     */
    create: XOR<SeatBedCreateInput, SeatBedUncheckedCreateInput>
    /**
     * In case the SeatBed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatBedUpdateInput, SeatBedUncheckedUpdateInput>
  }

  /**
   * SeatBed delete
   */
  export type SeatBedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    /**
     * Filter which SeatBed to delete.
     */
    where: SeatBedWhereUniqueInput
  }

  /**
   * SeatBed deleteMany
   */
  export type SeatBedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatBeds to delete
     */
    where?: SeatBedWhereInput
  }

  /**
   * SeatBed.booking
   */
  export type SeatBed$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * SeatBed without action
   */
  export type SeatBedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
  }


  /**
   * Model Food
   */

  export type AggregateFood = {
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  export type FoodAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    propertyId: number | null
  }

  export type FoodSumAggregateOutputType = {
    id: number | null
    rating: number | null
    propertyId: number | null
  }

  export type FoodMinAggregateOutputType = {
    id: number | null
    name: string | null
    rating: number | null
    propertyId: number | null
    description: string | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rating: number | null
    propertyId: number | null
    description: string | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodCountAggregateOutputType = {
    id: number
    name: number
    images: number
    optionalData: number
    rating: number
    propertyId: number
    price: number
    description: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodAvgAggregateInputType = {
    id?: true
    rating?: true
    propertyId?: true
  }

  export type FoodSumAggregateInputType = {
    id?: true
    rating?: true
    propertyId?: true
  }

  export type FoodMinAggregateInputType = {
    id?: true
    name?: true
    rating?: true
    propertyId?: true
    description?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodMaxAggregateInputType = {
    id?: true
    name?: true
    rating?: true
    propertyId?: true
    description?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodCountAggregateInputType = {
    id?: true
    name?: true
    images?: true
    optionalData?: true
    rating?: true
    propertyId?: true
    price?: true
    description?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Food to aggregate.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foods
    **/
    _count?: true | FoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMaxAggregateInputType
  }

  export type GetFoodAggregateType<T extends FoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood[P]>
      : GetScalarType<T[P], AggregateFood[P]>
  }




  export type FoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithAggregationInput | FoodOrderByWithAggregationInput[]
    by: FoodScalarFieldEnum[] | FoodScalarFieldEnum
    having?: FoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCountAggregateInputType | true
    _avg?: FoodAvgAggregateInputType
    _sum?: FoodSumAggregateInputType
    _min?: FoodMinAggregateInputType
    _max?: FoodMaxAggregateInputType
  }

  export type FoodGroupByOutputType = {
    id: number
    name: string
    images: JsonValue | null
    optionalData: JsonValue | null
    rating: number
    propertyId: number
    price: JsonValue | null
    description: string | null
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  type GetFoodGroupByPayload<T extends FoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGroupByOutputType[P]>
        }
      >
    >


  export type FoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    images?: boolean
    optionalData?: boolean
    rating?: boolean
    propertyId?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    images?: boolean
    optionalData?: boolean
    rating?: boolean
    propertyId?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectScalar = {
    id?: boolean
    name?: boolean
    images?: boolean
    optionalData?: boolean
    rating?: boolean
    propertyId?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type FoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $FoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Food"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      images: Prisma.JsonValue | null
      optionalData: Prisma.JsonValue | null
      rating: number
      propertyId: number
      price: Prisma.JsonValue | null
      description: string | null
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["food"]>
    composites: {}
  }

  type FoodGetPayload<S extends boolean | null | undefined | FoodDefaultArgs> = $Result.GetResult<Prisma.$FoodPayload, S>

  type FoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodCountAggregateInputType | true
    }

  export interface FoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Food'], meta: { name: 'Food' } }
    /**
     * Find zero or one Food that matches the filter.
     * @param {FoodFindUniqueArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodFindUniqueArgs>(args: SelectSubset<T, FoodFindUniqueArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Food that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodFindUniqueOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodFindFirstArgs>(args?: SelectSubset<T, FoodFindFirstArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foods
     * const foods = await prisma.food.findMany()
     * 
     * // Get first 10 Foods
     * const foods = await prisma.food.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodWithIdOnly = await prisma.food.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodFindManyArgs>(args?: SelectSubset<T, FoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Food.
     * @param {FoodCreateArgs} args - Arguments to create a Food.
     * @example
     * // Create one Food
     * const Food = await prisma.food.create({
     *   data: {
     *     // ... data to create a Food
     *   }
     * })
     * 
     */
    create<T extends FoodCreateArgs>(args: SelectSubset<T, FoodCreateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Foods.
     * @param {FoodCreateManyArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCreateManyArgs>(args?: SelectSubset<T, FoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Foods and returns the data saved in the database.
     * @param {FoodCreateManyAndReturnArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Foods and only return the `id`
     * const foodWithIdOnly = await prisma.food.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Food.
     * @param {FoodDeleteArgs} args - Arguments to delete one Food.
     * @example
     * // Delete one Food
     * const Food = await prisma.food.delete({
     *   where: {
     *     // ... filter to delete one Food
     *   }
     * })
     * 
     */
    delete<T extends FoodDeleteArgs>(args: SelectSubset<T, FoodDeleteArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Food.
     * @param {FoodUpdateArgs} args - Arguments to update one Food.
     * @example
     * // Update one Food
     * const food = await prisma.food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodUpdateArgs>(args: SelectSubset<T, FoodUpdateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Foods.
     * @param {FoodDeleteManyArgs} args - Arguments to filter Foods to delete.
     * @example
     * // Delete a few Foods
     * const { count } = await prisma.food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDeleteManyArgs>(args?: SelectSubset<T, FoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodUpdateManyArgs>(args: SelectSubset<T, FoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Food.
     * @param {FoodUpsertArgs} args - Arguments to update or create a Food.
     * @example
     * // Update or create a Food
     * const food = await prisma.food.upsert({
     *   create: {
     *     // ... data to create a Food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food we want to update
     *   }
     * })
     */
    upsert<T extends FoodUpsertArgs>(args: SelectSubset<T, FoodUpsertArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCountArgs} args - Arguments to filter Foods to count.
     * @example
     * // Count the number of Foods
     * const count = await prisma.food.count({
     *   where: {
     *     // ... the filter for the Foods we want to count
     *   }
     * })
    **/
    count<T extends FoodCountArgs>(
      args?: Subset<T, FoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodAggregateArgs>(args: Subset<T, FoodAggregateArgs>): Prisma.PrismaPromise<GetFoodAggregateType<T>>

    /**
     * Group by Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Food model
   */
  readonly fields: FoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Food model
   */ 
  interface FoodFieldRefs {
    readonly id: FieldRef<"Food", 'Int'>
    readonly name: FieldRef<"Food", 'String'>
    readonly images: FieldRef<"Food", 'Json'>
    readonly optionalData: FieldRef<"Food", 'Json'>
    readonly rating: FieldRef<"Food", 'Float'>
    readonly propertyId: FieldRef<"Food", 'Int'>
    readonly price: FieldRef<"Food", 'Json'>
    readonly description: FieldRef<"Food", 'String'>
    readonly status: FieldRef<"Food", 'Boolean'>
    readonly deletedAt: FieldRef<"Food", 'DateTime'>
    readonly createdAt: FieldRef<"Food", 'DateTime'>
    readonly updatedAt: FieldRef<"Food", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Food findUnique
   */
  export type FoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findUniqueOrThrow
   */
  export type FoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findFirst
   */
  export type FoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findFirstOrThrow
   */
  export type FoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findMany
   */
  export type FoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Foods to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food create
   */
  export type FoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to create a Food.
     */
    data: XOR<FoodCreateInput, FoodUncheckedCreateInput>
  }

  /**
   * Food createMany
   */
  export type FoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Food createManyAndReturn
   */
  export type FoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Food update
   */
  export type FoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to update a Food.
     */
    data: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
    /**
     * Choose, which Food to update.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food updateMany
   */
  export type FoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
  }

  /**
   * Food upsert
   */
  export type FoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The filter to search for the Food to update in case it exists.
     */
    where: FoodWhereUniqueInput
    /**
     * In case the Food found by the `where` argument doesn't exist, create a new Food with this data.
     */
    create: XOR<FoodCreateInput, FoodUncheckedCreateInput>
    /**
     * In case the Food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
  }

  /**
   * Food delete
   */
  export type FoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter which Food to delete.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food deleteMany
   */
  export type FoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foods to delete
     */
    where?: FoodWhereInput
  }

  /**
   * Food without action
   */
  export type FoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    id: number | null
    signature: number | null
  }

  export type SectionSumAggregateOutputType = {
    id: number | null
    signature: number | null
  }

  export type SectionMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    subtitle: string | null
    pattern: string | null
    contains: $Enums.ContentType | null
    signature: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    subtitle: string | null
    pattern: string | null
    contains: $Enums.ContentType | null
    signature: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    subtitle: number
    pattern: number
    contains: number
    signature: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    id?: true
    signature?: true
  }

  export type SectionSumAggregateInputType = {
    id?: true
    signature?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    subtitle?: true
    pattern?: true
    contains?: true
    signature?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    subtitle?: true
    pattern?: true
    contains?: true
    signature?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    subtitle?: true
    pattern?: true
    contains?: true
    signature?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: number
    title: string
    slug: string | null
    subtitle: string | null
    pattern: string
    contains: $Enums.ContentType
    signature: number
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    subtitle?: boolean
    pattern?: boolean
    contains?: boolean
    signature?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    subtitle?: boolean
    pattern?: boolean
    contains?: boolean
    signature?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    subtitle?: boolean
    pattern?: boolean
    contains?: boolean
    signature?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string | null
      subtitle: string | null
      pattern: string
      contains: $Enums.ContentType
      signature: number
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */ 
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'Int'>
    readonly title: FieldRef<"Section", 'String'>
    readonly slug: FieldRef<"Section", 'String'>
    readonly subtitle: FieldRef<"Section", 'String'>
    readonly pattern: FieldRef<"Section", 'String'>
    readonly contains: FieldRef<"Section", 'ContentType'>
    readonly signature: FieldRef<"Section", 'Int'>
    readonly status: FieldRef<"Section", 'Boolean'>
    readonly deletedAt: FieldRef<"Section", 'DateTime'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly updatedAt: FieldRef<"Section", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
  }


  /**
   * Model Events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    capacity: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    capacity: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    location: string | null
    mapLocation: string | null
    address: string | null
    capacity: number | null
    startDate: Date | null
    endDate: Date | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    location: string | null
    mapLocation: string | null
    address: string | null
    capacity: number | null
    startDate: Date | null
    endDate: Date | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    propertyId: number
    branchId: number
    location: number
    mapLocation: number
    address: number
    capacity: number
    startDate: number
    endDate: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    capacity?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    capacity?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    location?: true
    mapLocation?: true
    address?: true
    capacity?: true
    startDate?: true
    endDate?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    location?: true
    mapLocation?: true
    address?: true
    capacity?: true
    startDate?: true
    endDate?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    location?: true
    mapLocation?: true
    address?: true
    capacity?: true
    startDate?: true
    endDate?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to aggregate.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithAggregationInput | EventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: number
    propertyId: number
    branchId: number | null
    location: string | null
    mapLocation: string | null
    address: string | null
    capacity: number
    startDate: Date
    endDate: Date | null
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    branchId?: boolean
    location?: boolean
    mapLocation?: boolean
    address?: boolean
    capacity?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    branch?: boolean | Events$branchArgs<ExtArgs>
    evbooking?: boolean | Events$evbookingArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    branchId?: boolean
    location?: boolean
    mapLocation?: boolean
    address?: boolean
    capacity?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    branch?: boolean | Events$branchArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectScalar = {
    id?: boolean
    propertyId?: boolean
    branchId?: boolean
    location?: boolean
    mapLocation?: boolean
    address?: boolean
    capacity?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    branch?: boolean | Events$branchArgs<ExtArgs>
    evbooking?: boolean | Events$evbookingArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    branch?: boolean | Events$branchArgs<ExtArgs>
  }

  export type $EventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Events"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      evbooking: Prisma.$EvbookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      branchId: number | null
      location: string | null
      mapLocation: string | null
      address: string | null
      capacity: number
      startDate: Date
      endDate: Date | null
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type EventsGetPayload<S extends boolean | null | undefined | EventsDefaultArgs> = $Result.GetResult<Prisma.$EventsPayload, S>

  type EventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface EventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Events'], meta: { name: 'Events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsFindUniqueArgs>(args: SelectSubset<T, EventsFindUniqueArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsFindFirstArgs>(args?: SelectSubset<T, EventsFindFirstArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventsFindManyArgs>(args?: SelectSubset<T, EventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends EventsCreateArgs>(args: SelectSubset<T, EventsCreateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsCreateManyArgs>(args?: SelectSubset<T, EventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventsCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends EventsDeleteArgs>(args: SelectSubset<T, EventsDeleteArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsUpdateArgs>(args: SelectSubset<T, EventsUpdateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsDeleteManyArgs>(args?: SelectSubset<T, EventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsUpdateManyArgs>(args: SelectSubset<T, EventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends EventsUpsertArgs>(args: SelectSubset<T, EventsUpsertArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Events model
   */
  readonly fields: EventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends Events$branchArgs<ExtArgs> = {}>(args?: Subset<T, Events$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    evbooking<T extends Events$evbookingArgs<ExtArgs> = {}>(args?: Subset<T, Events$evbookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Events model
   */ 
  interface EventsFieldRefs {
    readonly id: FieldRef<"Events", 'Int'>
    readonly propertyId: FieldRef<"Events", 'Int'>
    readonly branchId: FieldRef<"Events", 'Int'>
    readonly location: FieldRef<"Events", 'String'>
    readonly mapLocation: FieldRef<"Events", 'String'>
    readonly address: FieldRef<"Events", 'String'>
    readonly capacity: FieldRef<"Events", 'Int'>
    readonly startDate: FieldRef<"Events", 'DateTime'>
    readonly endDate: FieldRef<"Events", 'DateTime'>
    readonly status: FieldRef<"Events", 'Boolean'>
    readonly deletedAt: FieldRef<"Events", 'DateTime'>
    readonly createdAt: FieldRef<"Events", 'DateTime'>
    readonly updatedAt: FieldRef<"Events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findMany
   */
  export type EventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events create
   */
  export type EventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to create a Events.
     */
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }

  /**
   * Events createMany
   */
  export type EventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Events createManyAndReturn
   */
  export type EventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Events update
   */
  export type EventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to update a Events.
     */
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
  }

  /**
   * Events upsert
   */
  export type EventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The filter to search for the Events to update in case it exists.
     */
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     */
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }

  /**
   * Events delete
   */
  export type EventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter which Events to delete.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventsWhereInput
  }

  /**
   * Events.branch
   */
  export type Events$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Events.evbooking
   */
  export type Events$evbookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    where?: EvbookingWhereInput
    orderBy?: EvbookingOrderByWithRelationInput | EvbookingOrderByWithRelationInput[]
    cursor?: EvbookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvbookingScalarFieldEnum | EvbookingScalarFieldEnum[]
  }

  /**
   * Events without action
   */
  export type EventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    tableId: number | null
    seatBedId: number | null
    ownerId: number | null
    customerId: number | null
    guestNumber: number | null
    amount: number | null
    vat: number | null
    discount: number | null
    grandTotal: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    tableId: number | null
    seatBedId: number | null
    ownerId: number | null
    customerId: number | null
    guestNumber: number | null
    amount: number | null
    vat: number | null
    discount: number | null
    grandTotal: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    tableId: number | null
    seatBedId: number | null
    ownerId: number | null
    customerId: number | null
    customerName: string | null
    phoneNumber: string | null
    startDate: Date | null
    endDate: Date | null
    slot: string | null
    comment: string | null
    customerRequest: string | null
    cancelReason: string | null
    guestNumber: number | null
    amount: number | null
    vat: number | null
    discount: number | null
    grandTotal: number | null
    status: $Enums.BookingStatus | null
    bookingType: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    branchId: number | null
    tableId: number | null
    seatBedId: number | null
    ownerId: number | null
    customerId: number | null
    customerName: string | null
    phoneNumber: string | null
    startDate: Date | null
    endDate: Date | null
    slot: string | null
    comment: string | null
    customerRequest: string | null
    cancelReason: string | null
    guestNumber: number | null
    amount: number | null
    vat: number | null
    discount: number | null
    grandTotal: number | null
    status: $Enums.BookingStatus | null
    bookingType: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    propertyId: number
    branchId: number
    tableId: number
    seatBedId: number
    ownerId: number
    customerId: number
    customerName: number
    phoneNumber: number
    startDate: number
    endDate: number
    slot: number
    comment: number
    customerRequest: number
    cancelReason: number
    guestNumber: number
    amount: number
    vat: number
    discount: number
    grandTotal: number
    status: number
    bookingType: number
    optionalData: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    tableId?: true
    seatBedId?: true
    ownerId?: true
    customerId?: true
    guestNumber?: true
    amount?: true
    vat?: true
    discount?: true
    grandTotal?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    tableId?: true
    seatBedId?: true
    ownerId?: true
    customerId?: true
    guestNumber?: true
    amount?: true
    vat?: true
    discount?: true
    grandTotal?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    tableId?: true
    seatBedId?: true
    ownerId?: true
    customerId?: true
    customerName?: true
    phoneNumber?: true
    startDate?: true
    endDate?: true
    slot?: true
    comment?: true
    customerRequest?: true
    cancelReason?: true
    guestNumber?: true
    amount?: true
    vat?: true
    discount?: true
    grandTotal?: true
    status?: true
    bookingType?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    tableId?: true
    seatBedId?: true
    ownerId?: true
    customerId?: true
    customerName?: true
    phoneNumber?: true
    startDate?: true
    endDate?: true
    slot?: true
    comment?: true
    customerRequest?: true
    cancelReason?: true
    guestNumber?: true
    amount?: true
    vat?: true
    discount?: true
    grandTotal?: true
    status?: true
    bookingType?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    propertyId?: true
    branchId?: true
    tableId?: true
    seatBedId?: true
    ownerId?: true
    customerId?: true
    customerName?: true
    phoneNumber?: true
    startDate?: true
    endDate?: true
    slot?: true
    comment?: true
    customerRequest?: true
    cancelReason?: true
    guestNumber?: true
    amount?: true
    vat?: true
    discount?: true
    grandTotal?: true
    status?: true
    bookingType?: true
    optionalData?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    propertyId: number | null
    branchId: number
    tableId: number | null
    seatBedId: number | null
    ownerId: number | null
    customerId: number | null
    customerName: string
    phoneNumber: string | null
    startDate: Date
    endDate: Date
    slot: string | null
    comment: string | null
    customerRequest: string | null
    cancelReason: string | null
    guestNumber: number | null
    amount: number
    vat: number
    discount: number
    grandTotal: number
    status: $Enums.BookingStatus
    bookingType: string | null
    optionalData: JsonValue | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    branchId?: boolean
    tableId?: boolean
    seatBedId?: boolean
    ownerId?: boolean
    customerId?: boolean
    customerName?: boolean
    phoneNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    slot?: boolean
    comment?: boolean
    customerRequest?: boolean
    cancelReason?: boolean
    guestNumber?: boolean
    amount?: boolean
    vat?: boolean
    discount?: boolean
    grandTotal?: boolean
    status?: boolean
    bookingType?: boolean
    optionalData?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | Booking$propertyArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    table?: boolean | Booking$tableArgs<ExtArgs>
    seatBed?: boolean | Booking$seatBedArgs<ExtArgs>
    owner?: boolean | Booking$ownerArgs<ExtArgs>
    customer?: boolean | Booking$customerArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    branchId?: boolean
    tableId?: boolean
    seatBedId?: boolean
    ownerId?: boolean
    customerId?: boolean
    customerName?: boolean
    phoneNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    slot?: boolean
    comment?: boolean
    customerRequest?: boolean
    cancelReason?: boolean
    guestNumber?: boolean
    amount?: boolean
    vat?: boolean
    discount?: boolean
    grandTotal?: boolean
    status?: boolean
    bookingType?: boolean
    optionalData?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | Booking$propertyArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    table?: boolean | Booking$tableArgs<ExtArgs>
    seatBed?: boolean | Booking$seatBedArgs<ExtArgs>
    owner?: boolean | Booking$ownerArgs<ExtArgs>
    customer?: boolean | Booking$customerArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    propertyId?: boolean
    branchId?: boolean
    tableId?: boolean
    seatBedId?: boolean
    ownerId?: boolean
    customerId?: boolean
    customerName?: boolean
    phoneNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    slot?: boolean
    comment?: boolean
    customerRequest?: boolean
    cancelReason?: boolean
    guestNumber?: boolean
    amount?: boolean
    vat?: boolean
    discount?: boolean
    grandTotal?: boolean
    status?: boolean
    bookingType?: boolean
    optionalData?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Booking$propertyArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    table?: boolean | Booking$tableArgs<ExtArgs>
    seatBed?: boolean | Booking$seatBedArgs<ExtArgs>
    owner?: boolean | Booking$ownerArgs<ExtArgs>
    customer?: boolean | Booking$customerArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Booking$propertyArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    table?: boolean | Booking$tableArgs<ExtArgs>
    seatBed?: boolean | Booking$seatBedArgs<ExtArgs>
    owner?: boolean | Booking$ownerArgs<ExtArgs>
    customer?: boolean | Booking$customerArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs>
      table: Prisma.$TablePayload<ExtArgs> | null
      seatBed: Prisma.$SeatBedPayload<ExtArgs> | null
      owner: Prisma.$OwnerPayload<ExtArgs> | null
      customer: Prisma.$UserPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number | null
      branchId: number
      tableId: number | null
      seatBedId: number | null
      ownerId: number | null
      customerId: number | null
      customerName: string
      phoneNumber: string | null
      startDate: Date
      endDate: Date
      slot: string | null
      comment: string | null
      customerRequest: string | null
      cancelReason: string | null
      guestNumber: number | null
      amount: number
      vat: number
      discount: number
      grandTotal: number
      status: $Enums.BookingStatus
      bookingType: string | null
      optionalData: Prisma.JsonValue | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends Booking$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Booking$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    table<T extends Booking$tableArgs<ExtArgs> = {}>(args?: Subset<T, Booking$tableArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    seatBed<T extends Booking$seatBedArgs<ExtArgs> = {}>(args?: Subset<T, Booking$seatBedArgs<ExtArgs>>): Prisma__SeatBedClient<$Result.GetResult<Prisma.$SeatBedPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends Booking$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Booking$ownerArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends Booking$customerArgs<ExtArgs> = {}>(args?: Subset<T, Booking$customerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly propertyId: FieldRef<"Booking", 'Int'>
    readonly branchId: FieldRef<"Booking", 'Int'>
    readonly tableId: FieldRef<"Booking", 'Int'>
    readonly seatBedId: FieldRef<"Booking", 'Int'>
    readonly ownerId: FieldRef<"Booking", 'Int'>
    readonly customerId: FieldRef<"Booking", 'Int'>
    readonly customerName: FieldRef<"Booking", 'String'>
    readonly phoneNumber: FieldRef<"Booking", 'String'>
    readonly startDate: FieldRef<"Booking", 'DateTime'>
    readonly endDate: FieldRef<"Booking", 'DateTime'>
    readonly slot: FieldRef<"Booking", 'String'>
    readonly comment: FieldRef<"Booking", 'String'>
    readonly customerRequest: FieldRef<"Booking", 'String'>
    readonly cancelReason: FieldRef<"Booking", 'String'>
    readonly guestNumber: FieldRef<"Booking", 'Int'>
    readonly amount: FieldRef<"Booking", 'Int'>
    readonly vat: FieldRef<"Booking", 'Int'>
    readonly discount: FieldRef<"Booking", 'Int'>
    readonly grandTotal: FieldRef<"Booking", 'Int'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly bookingType: FieldRef<"Booking", 'String'>
    readonly optionalData: FieldRef<"Booking", 'Json'>
    readonly deletedAt: FieldRef<"Booking", 'DateTime'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.property
   */
  export type Booking$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Booking.table
   */
  export type Booking$tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
  }

  /**
   * Booking.seatBed
   */
  export type Booking$seatBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatBed
     */
    select?: SeatBedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatBedInclude<ExtArgs> | null
    where?: SeatBedWhereInput
  }

  /**
   * Booking.owner
   */
  export type Booking$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    where?: OwnerWhereInput
  }

  /**
   * Booking.customer
   */
  export type Booking$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    paymentDate: Date | null
    paymentInfo: string | null
    status: $Enums.PaymentStatus | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    paymentDate: Date | null
    paymentInfo: string | null
    status: $Enums.PaymentStatus | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    paymentDate: number
    paymentInfo: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    paymentDate?: true
    paymentInfo?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    paymentDate?: true
    paymentInfo?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    paymentDate?: true
    paymentInfo?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    bookingId: number
    paymentDate: Date | null
    paymentInfo: string | null
    status: $Enums.PaymentStatus
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentDate?: boolean
    paymentInfo?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentDate?: boolean
    paymentInfo?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    paymentDate?: boolean
    paymentInfo?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      paymentDate: Date | null
      paymentInfo: string | null
      status: $Enums.PaymentStatus
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly bookingId: FieldRef<"Payment", 'Int'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentInfo: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly deletedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Amenities
   */

  export type AggregateAmenities = {
    _count: AmenitiesCountAggregateOutputType | null
    _avg: AmenitiesAvgAggregateOutputType | null
    _sum: AmenitiesSumAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  export type AmenitiesAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type AmenitiesSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type AmenitiesMinAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    price: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenitiesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    price: number | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenitiesCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    price: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmenitiesAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type AmenitiesSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type AmenitiesMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    price?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenitiesMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    price?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenitiesCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    price?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to aggregate.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenitiesMaxAggregateInputType
  }

  export type GetAmenitiesAggregateType<T extends AmenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenities[P]>
      : GetScalarType<T[P], AggregateAmenities[P]>
  }




  export type AmenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithAggregationInput | AmenitiesOrderByWithAggregationInput[]
    by: AmenitiesScalarFieldEnum[] | AmenitiesScalarFieldEnum
    having?: AmenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenitiesCountAggregateInputType | true
    _avg?: AmenitiesAvgAggregateInputType
    _sum?: AmenitiesSumAggregateInputType
    _min?: AmenitiesMinAggregateInputType
    _max?: AmenitiesMaxAggregateInputType
  }

  export type AmenitiesGroupByOutputType = {
    id: number
    name: string
    icon: string | null
    price: number
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AmenitiesCountAggregateOutputType | null
    _avg: AmenitiesAvgAggregateOutputType | null
    _sum: AmenitiesSumAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  type GetAmenitiesGroupByPayload<T extends AmenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
        }
      >
    >


  export type AmenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    price?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    price?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    price?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AmenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      icon: string | null
      price: number
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amenities"]>
    composites: {}
  }

  type AmenitiesGetPayload<S extends boolean | null | undefined | AmenitiesDefaultArgs> = $Result.GetResult<Prisma.$AmenitiesPayload, S>

  type AmenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AmenitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AmenitiesCountAggregateInputType | true
    }

  export interface AmenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenities'], meta: { name: 'Amenities' } }
    /**
     * Find zero or one Amenities that matches the filter.
     * @param {AmenitiesFindUniqueArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenitiesFindUniqueArgs>(args: SelectSubset<T, AmenitiesFindUniqueArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Amenities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AmenitiesFindUniqueOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenitiesFindFirstArgs>(args?: SelectSubset<T, AmenitiesFindFirstArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenities.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenitiesFindManyArgs>(args?: SelectSubset<T, AmenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Amenities.
     * @param {AmenitiesCreateArgs} args - Arguments to create a Amenities.
     * @example
     * // Create one Amenities
     * const Amenities = await prisma.amenities.create({
     *   data: {
     *     // ... data to create a Amenities
     *   }
     * })
     * 
     */
    create<T extends AmenitiesCreateArgs>(args: SelectSubset<T, AmenitiesCreateArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Amenities.
     * @param {AmenitiesCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenitiesCreateManyArgs>(args?: SelectSubset<T, AmenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenitiesCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Amenities.
     * @param {AmenitiesDeleteArgs} args - Arguments to delete one Amenities.
     * @example
     * // Delete one Amenities
     * const Amenities = await prisma.amenities.delete({
     *   where: {
     *     // ... filter to delete one Amenities
     *   }
     * })
     * 
     */
    delete<T extends AmenitiesDeleteArgs>(args: SelectSubset<T, AmenitiesDeleteArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Amenities.
     * @param {AmenitiesUpdateArgs} args - Arguments to update one Amenities.
     * @example
     * // Update one Amenities
     * const amenities = await prisma.amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenitiesUpdateArgs>(args: SelectSubset<T, AmenitiesUpdateArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Amenities.
     * @param {AmenitiesDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenitiesDeleteManyArgs>(args?: SelectSubset<T, AmenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenitiesUpdateManyArgs>(args: SelectSubset<T, AmenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenities.
     * @param {AmenitiesUpsertArgs} args - Arguments to update or create a Amenities.
     * @example
     * // Update or create a Amenities
     * const amenities = await prisma.amenities.upsert({
     *   create: {
     *     // ... data to create a Amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenities we want to update
     *   }
     * })
     */
    upsert<T extends AmenitiesUpsertArgs>(args: SelectSubset<T, AmenitiesUpsertArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenities.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenitiesCountArgs>(
      args?: Subset<T, AmenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenitiesAggregateArgs>(args: Subset<T, AmenitiesAggregateArgs>): Prisma.PrismaPromise<GetAmenitiesAggregateType<T>>

    /**
     * Group by Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenitiesGroupByArgs['orderBy'] }
        : { orderBy?: AmenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenities model
   */
  readonly fields: AmenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenities model
   */ 
  interface AmenitiesFieldRefs {
    readonly id: FieldRef<"Amenities", 'Int'>
    readonly name: FieldRef<"Amenities", 'String'>
    readonly icon: FieldRef<"Amenities", 'String'>
    readonly price: FieldRef<"Amenities", 'Float'>
    readonly status: FieldRef<"Amenities", 'Boolean'>
    readonly deletedAt: FieldRef<"Amenities", 'DateTime'>
    readonly createdAt: FieldRef<"Amenities", 'DateTime'>
    readonly updatedAt: FieldRef<"Amenities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenities findUnique
   */
  export type AmenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities findUniqueOrThrow
   */
  export type AmenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities findFirst
   */
  export type AmenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Amenities findFirstOrThrow
   */
  export type AmenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Amenities findMany
   */
  export type AmenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Amenities create
   */
  export type AmenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * The data needed to create a Amenities.
     */
    data: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
  }

  /**
   * Amenities createMany
   */
  export type AmenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenities createManyAndReturn
   */
  export type AmenitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenities update
   */
  export type AmenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * The data needed to update a Amenities.
     */
    data: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
    /**
     * Choose, which Amenities to update.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities updateMany
   */
  export type AmenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenitiesWhereInput
  }

  /**
   * Amenities upsert
   */
  export type AmenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * The filter to search for the Amenities to update in case it exists.
     */
    where: AmenitiesWhereUniqueInput
    /**
     * In case the Amenities found by the `where` argument doesn't exist, create a new Amenities with this data.
     */
    create: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
    /**
     * In case the Amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
  }

  /**
   * Amenities delete
   */
  export type AmenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Filter which Amenities to delete.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities deleteMany
   */
  export type AmenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenitiesWhereInput
  }

  /**
   * Amenities without action
   */
  export type AmenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
  }


  /**
   * Model Cuisine
   */

  export type AggregateCuisine = {
    _count: CuisineCountAggregateOutputType | null
    _avg: CuisineAvgAggregateOutputType | null
    _sum: CuisineSumAggregateOutputType | null
    _min: CuisineMinAggregateOutputType | null
    _max: CuisineMaxAggregateOutputType | null
  }

  export type CuisineAvgAggregateOutputType = {
    id: number | null
  }

  export type CuisineSumAggregateOutputType = {
    id: number | null
  }

  export type CuisineMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuisineMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuisineCountAggregateOutputType = {
    id: number
    name: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CuisineAvgAggregateInputType = {
    id?: true
  }

  export type CuisineSumAggregateInputType = {
    id?: true
  }

  export type CuisineMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuisineMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuisineCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CuisineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuisine to aggregate.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cuisines
    **/
    _count?: true | CuisineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuisineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuisineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuisineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuisineMaxAggregateInputType
  }

  export type GetCuisineAggregateType<T extends CuisineAggregateArgs> = {
        [P in keyof T & keyof AggregateCuisine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuisine[P]>
      : GetScalarType<T[P], AggregateCuisine[P]>
  }




  export type CuisineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuisineWhereInput
    orderBy?: CuisineOrderByWithAggregationInput | CuisineOrderByWithAggregationInput[]
    by: CuisineScalarFieldEnum[] | CuisineScalarFieldEnum
    having?: CuisineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuisineCountAggregateInputType | true
    _avg?: CuisineAvgAggregateInputType
    _sum?: CuisineSumAggregateInputType
    _min?: CuisineMinAggregateInputType
    _max?: CuisineMaxAggregateInputType
  }

  export type CuisineGroupByOutputType = {
    id: number
    name: string
    status: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CuisineCountAggregateOutputType | null
    _avg: CuisineAvgAggregateOutputType | null
    _sum: CuisineSumAggregateOutputType | null
    _min: CuisineMinAggregateOutputType | null
    _max: CuisineMaxAggregateOutputType | null
  }

  type GetCuisineGroupByPayload<T extends CuisineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuisineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuisineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuisineGroupByOutputType[P]>
            : GetScalarType<T[P], CuisineGroupByOutputType[P]>
        }
      >
    >


  export type CuisineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cuisine"]>

  export type CuisineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cuisine"]>

  export type CuisineSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CuisinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cuisine"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      status: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cuisine"]>
    composites: {}
  }

  type CuisineGetPayload<S extends boolean | null | undefined | CuisineDefaultArgs> = $Result.GetResult<Prisma.$CuisinePayload, S>

  type CuisineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CuisineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CuisineCountAggregateInputType | true
    }

  export interface CuisineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cuisine'], meta: { name: 'Cuisine' } }
    /**
     * Find zero or one Cuisine that matches the filter.
     * @param {CuisineFindUniqueArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CuisineFindUniqueArgs>(args: SelectSubset<T, CuisineFindUniqueArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cuisine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CuisineFindUniqueOrThrowArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CuisineFindUniqueOrThrowArgs>(args: SelectSubset<T, CuisineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cuisine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineFindFirstArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CuisineFindFirstArgs>(args?: SelectSubset<T, CuisineFindFirstArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cuisine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineFindFirstOrThrowArgs} args - Arguments to find a Cuisine
     * @example
     * // Get one Cuisine
     * const cuisine = await prisma.cuisine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CuisineFindFirstOrThrowArgs>(args?: SelectSubset<T, CuisineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cuisines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuisines
     * const cuisines = await prisma.cuisine.findMany()
     * 
     * // Get first 10 Cuisines
     * const cuisines = await prisma.cuisine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cuisineWithIdOnly = await prisma.cuisine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CuisineFindManyArgs>(args?: SelectSubset<T, CuisineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cuisine.
     * @param {CuisineCreateArgs} args - Arguments to create a Cuisine.
     * @example
     * // Create one Cuisine
     * const Cuisine = await prisma.cuisine.create({
     *   data: {
     *     // ... data to create a Cuisine
     *   }
     * })
     * 
     */
    create<T extends CuisineCreateArgs>(args: SelectSubset<T, CuisineCreateArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cuisines.
     * @param {CuisineCreateManyArgs} args - Arguments to create many Cuisines.
     * @example
     * // Create many Cuisines
     * const cuisine = await prisma.cuisine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CuisineCreateManyArgs>(args?: SelectSubset<T, CuisineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cuisines and returns the data saved in the database.
     * @param {CuisineCreateManyAndReturnArgs} args - Arguments to create many Cuisines.
     * @example
     * // Create many Cuisines
     * const cuisine = await prisma.cuisine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cuisines and only return the `id`
     * const cuisineWithIdOnly = await prisma.cuisine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CuisineCreateManyAndReturnArgs>(args?: SelectSubset<T, CuisineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cuisine.
     * @param {CuisineDeleteArgs} args - Arguments to delete one Cuisine.
     * @example
     * // Delete one Cuisine
     * const Cuisine = await prisma.cuisine.delete({
     *   where: {
     *     // ... filter to delete one Cuisine
     *   }
     * })
     * 
     */
    delete<T extends CuisineDeleteArgs>(args: SelectSubset<T, CuisineDeleteArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cuisine.
     * @param {CuisineUpdateArgs} args - Arguments to update one Cuisine.
     * @example
     * // Update one Cuisine
     * const cuisine = await prisma.cuisine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CuisineUpdateArgs>(args: SelectSubset<T, CuisineUpdateArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cuisines.
     * @param {CuisineDeleteManyArgs} args - Arguments to filter Cuisines to delete.
     * @example
     * // Delete a few Cuisines
     * const { count } = await prisma.cuisine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CuisineDeleteManyArgs>(args?: SelectSubset<T, CuisineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuisines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuisines
     * const cuisine = await prisma.cuisine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CuisineUpdateManyArgs>(args: SelectSubset<T, CuisineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cuisine.
     * @param {CuisineUpsertArgs} args - Arguments to update or create a Cuisine.
     * @example
     * // Update or create a Cuisine
     * const cuisine = await prisma.cuisine.upsert({
     *   create: {
     *     // ... data to create a Cuisine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuisine we want to update
     *   }
     * })
     */
    upsert<T extends CuisineUpsertArgs>(args: SelectSubset<T, CuisineUpsertArgs<ExtArgs>>): Prisma__CuisineClient<$Result.GetResult<Prisma.$CuisinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cuisines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineCountArgs} args - Arguments to filter Cuisines to count.
     * @example
     * // Count the number of Cuisines
     * const count = await prisma.cuisine.count({
     *   where: {
     *     // ... the filter for the Cuisines we want to count
     *   }
     * })
    **/
    count<T extends CuisineCountArgs>(
      args?: Subset<T, CuisineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuisineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuisine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuisineAggregateArgs>(args: Subset<T, CuisineAggregateArgs>): Prisma.PrismaPromise<GetCuisineAggregateType<T>>

    /**
     * Group by Cuisine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuisineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CuisineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CuisineGroupByArgs['orderBy'] }
        : { orderBy?: CuisineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CuisineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuisineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cuisine model
   */
  readonly fields: CuisineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cuisine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CuisineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cuisine model
   */ 
  interface CuisineFieldRefs {
    readonly id: FieldRef<"Cuisine", 'Int'>
    readonly name: FieldRef<"Cuisine", 'String'>
    readonly status: FieldRef<"Cuisine", 'Boolean'>
    readonly deletedAt: FieldRef<"Cuisine", 'DateTime'>
    readonly createdAt: FieldRef<"Cuisine", 'DateTime'>
    readonly updatedAt: FieldRef<"Cuisine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cuisine findUnique
   */
  export type CuisineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine findUniqueOrThrow
   */
  export type CuisineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine findFirst
   */
  export type CuisineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuisines.
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuisines.
     */
    distinct?: CuisineScalarFieldEnum | CuisineScalarFieldEnum[]
  }

  /**
   * Cuisine findFirstOrThrow
   */
  export type CuisineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Filter, which Cuisine to fetch.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuisines.
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuisines.
     */
    distinct?: CuisineScalarFieldEnum | CuisineScalarFieldEnum[]
  }

  /**
   * Cuisine findMany
   */
  export type CuisineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Filter, which Cuisines to fetch.
     */
    where?: CuisineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuisines to fetch.
     */
    orderBy?: CuisineOrderByWithRelationInput | CuisineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cuisines.
     */
    cursor?: CuisineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuisines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuisines.
     */
    skip?: number
    distinct?: CuisineScalarFieldEnum | CuisineScalarFieldEnum[]
  }

  /**
   * Cuisine create
   */
  export type CuisineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * The data needed to create a Cuisine.
     */
    data: XOR<CuisineCreateInput, CuisineUncheckedCreateInput>
  }

  /**
   * Cuisine createMany
   */
  export type CuisineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cuisines.
     */
    data: CuisineCreateManyInput | CuisineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cuisine createManyAndReturn
   */
  export type CuisineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cuisines.
     */
    data: CuisineCreateManyInput | CuisineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cuisine update
   */
  export type CuisineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * The data needed to update a Cuisine.
     */
    data: XOR<CuisineUpdateInput, CuisineUncheckedUpdateInput>
    /**
     * Choose, which Cuisine to update.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine updateMany
   */
  export type CuisineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cuisines.
     */
    data: XOR<CuisineUpdateManyMutationInput, CuisineUncheckedUpdateManyInput>
    /**
     * Filter which Cuisines to update
     */
    where?: CuisineWhereInput
  }

  /**
   * Cuisine upsert
   */
  export type CuisineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * The filter to search for the Cuisine to update in case it exists.
     */
    where: CuisineWhereUniqueInput
    /**
     * In case the Cuisine found by the `where` argument doesn't exist, create a new Cuisine with this data.
     */
    create: XOR<CuisineCreateInput, CuisineUncheckedCreateInput>
    /**
     * In case the Cuisine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CuisineUpdateInput, CuisineUncheckedUpdateInput>
  }

  /**
   * Cuisine delete
   */
  export type CuisineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
    /**
     * Filter which Cuisine to delete.
     */
    where: CuisineWhereUniqueInput
  }

  /**
   * Cuisine deleteMany
   */
  export type CuisineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuisines to delete
     */
    where?: CuisineWhereInput
  }

  /**
   * Cuisine without action
   */
  export type CuisineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuisine
     */
    select?: CuisineSelect<ExtArgs> | null
  }


  /**
   * Model Evbooking
   */

  export type AggregateEvbooking = {
    _count: EvbookingCountAggregateOutputType | null
    _avg: EvbookingAvgAggregateOutputType | null
    _sum: EvbookingSumAggregateOutputType | null
    _min: EvbookingMinAggregateOutputType | null
    _max: EvbookingMaxAggregateOutputType | null
  }

  export type EvbookingAvgAggregateOutputType = {
    id: number | null
    person: number | null
    price: number | null
    amount: number | null
    vat: number | null
    eventId: number | null
  }

  export type EvbookingSumAggregateOutputType = {
    id: number | null
    person: number | null
    price: number | null
    amount: number | null
    vat: number | null
    eventId: number | null
  }

  export type EvbookingMinAggregateOutputType = {
    id: number | null
    username: string | null
    phoneNumber: string | null
    email: string | null
    address: string | null
    ticketNumber: string | null
    person: number | null
    price: number | null
    amount: number | null
    vat: number | null
    payStatus: $Enums.PaymentStatus | null
    eventDate: Date | null
    eventId: number | null
    status: boolean | null
    issueAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvbookingMaxAggregateOutputType = {
    id: number | null
    username: string | null
    phoneNumber: string | null
    email: string | null
    address: string | null
    ticketNumber: string | null
    person: number | null
    price: number | null
    amount: number | null
    vat: number | null
    payStatus: $Enums.PaymentStatus | null
    eventDate: Date | null
    eventId: number | null
    status: boolean | null
    issueAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvbookingCountAggregateOutputType = {
    id: number
    username: number
    phoneNumber: number
    email: number
    address: number
    ticketNumber: number
    person: number
    price: number
    amount: number
    vat: number
    payStatus: number
    eventDate: number
    eventId: number
    status: number
    optionalData: number
    issueAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvbookingAvgAggregateInputType = {
    id?: true
    person?: true
    price?: true
    amount?: true
    vat?: true
    eventId?: true
  }

  export type EvbookingSumAggregateInputType = {
    id?: true
    person?: true
    price?: true
    amount?: true
    vat?: true
    eventId?: true
  }

  export type EvbookingMinAggregateInputType = {
    id?: true
    username?: true
    phoneNumber?: true
    email?: true
    address?: true
    ticketNumber?: true
    person?: true
    price?: true
    amount?: true
    vat?: true
    payStatus?: true
    eventDate?: true
    eventId?: true
    status?: true
    issueAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvbookingMaxAggregateInputType = {
    id?: true
    username?: true
    phoneNumber?: true
    email?: true
    address?: true
    ticketNumber?: true
    person?: true
    price?: true
    amount?: true
    vat?: true
    payStatus?: true
    eventDate?: true
    eventId?: true
    status?: true
    issueAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvbookingCountAggregateInputType = {
    id?: true
    username?: true
    phoneNumber?: true
    email?: true
    address?: true
    ticketNumber?: true
    person?: true
    price?: true
    amount?: true
    vat?: true
    payStatus?: true
    eventDate?: true
    eventId?: true
    status?: true
    optionalData?: true
    issueAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvbookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evbooking to aggregate.
     */
    where?: EvbookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evbookings to fetch.
     */
    orderBy?: EvbookingOrderByWithRelationInput | EvbookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvbookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evbookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evbookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evbookings
    **/
    _count?: true | EvbookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvbookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvbookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvbookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvbookingMaxAggregateInputType
  }

  export type GetEvbookingAggregateType<T extends EvbookingAggregateArgs> = {
        [P in keyof T & keyof AggregateEvbooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvbooking[P]>
      : GetScalarType<T[P], AggregateEvbooking[P]>
  }




  export type EvbookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvbookingWhereInput
    orderBy?: EvbookingOrderByWithAggregationInput | EvbookingOrderByWithAggregationInput[]
    by: EvbookingScalarFieldEnum[] | EvbookingScalarFieldEnum
    having?: EvbookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvbookingCountAggregateInputType | true
    _avg?: EvbookingAvgAggregateInputType
    _sum?: EvbookingSumAggregateInputType
    _min?: EvbookingMinAggregateInputType
    _max?: EvbookingMaxAggregateInputType
  }

  export type EvbookingGroupByOutputType = {
    id: number
    username: string
    phoneNumber: string
    email: string | null
    address: string | null
    ticketNumber: string
    person: number
    price: number
    amount: number
    vat: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date
    eventId: number
    status: boolean
    optionalData: JsonValue | null
    issueAt: Date
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EvbookingCountAggregateOutputType | null
    _avg: EvbookingAvgAggregateOutputType | null
    _sum: EvbookingSumAggregateOutputType | null
    _min: EvbookingMinAggregateOutputType | null
    _max: EvbookingMaxAggregateOutputType | null
  }

  type GetEvbookingGroupByPayload<T extends EvbookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvbookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvbookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvbookingGroupByOutputType[P]>
            : GetScalarType<T[P], EvbookingGroupByOutputType[P]>
        }
      >
    >


  export type EvbookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    phoneNumber?: boolean
    email?: boolean
    address?: boolean
    ticketNumber?: boolean
    person?: boolean
    price?: boolean
    amount?: boolean
    vat?: boolean
    payStatus?: boolean
    eventDate?: boolean
    eventId?: boolean
    status?: boolean
    optionalData?: boolean
    issueAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evbooking"]>

  export type EvbookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    phoneNumber?: boolean
    email?: boolean
    address?: boolean
    ticketNumber?: boolean
    person?: boolean
    price?: boolean
    amount?: boolean
    vat?: boolean
    payStatus?: boolean
    eventDate?: boolean
    eventId?: boolean
    status?: boolean
    optionalData?: boolean
    issueAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evbooking"]>

  export type EvbookingSelectScalar = {
    id?: boolean
    username?: boolean
    phoneNumber?: boolean
    email?: boolean
    address?: boolean
    ticketNumber?: boolean
    person?: boolean
    price?: boolean
    amount?: boolean
    vat?: boolean
    payStatus?: boolean
    eventDate?: boolean
    eventId?: boolean
    status?: boolean
    optionalData?: boolean
    issueAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvbookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventsDefaultArgs<ExtArgs>
  }
  export type EvbookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventsDefaultArgs<ExtArgs>
  }

  export type $EvbookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evbooking"
    objects: {
      event: Prisma.$EventsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      phoneNumber: string
      email: string | null
      address: string | null
      ticketNumber: string
      person: number
      price: number
      amount: number
      vat: number
      payStatus: $Enums.PaymentStatus
      eventDate: Date
      eventId: number
      status: boolean
      optionalData: Prisma.JsonValue | null
      issueAt: Date
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evbooking"]>
    composites: {}
  }

  type EvbookingGetPayload<S extends boolean | null | undefined | EvbookingDefaultArgs> = $Result.GetResult<Prisma.$EvbookingPayload, S>

  type EvbookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvbookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvbookingCountAggregateInputType | true
    }

  export interface EvbookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evbooking'], meta: { name: 'Evbooking' } }
    /**
     * Find zero or one Evbooking that matches the filter.
     * @param {EvbookingFindUniqueArgs} args - Arguments to find a Evbooking
     * @example
     * // Get one Evbooking
     * const evbooking = await prisma.evbooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvbookingFindUniqueArgs>(args: SelectSubset<T, EvbookingFindUniqueArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evbooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvbookingFindUniqueOrThrowArgs} args - Arguments to find a Evbooking
     * @example
     * // Get one Evbooking
     * const evbooking = await prisma.evbooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvbookingFindUniqueOrThrowArgs>(args: SelectSubset<T, EvbookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evbooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingFindFirstArgs} args - Arguments to find a Evbooking
     * @example
     * // Get one Evbooking
     * const evbooking = await prisma.evbooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvbookingFindFirstArgs>(args?: SelectSubset<T, EvbookingFindFirstArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evbooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingFindFirstOrThrowArgs} args - Arguments to find a Evbooking
     * @example
     * // Get one Evbooking
     * const evbooking = await prisma.evbooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvbookingFindFirstOrThrowArgs>(args?: SelectSubset<T, EvbookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evbookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evbookings
     * const evbookings = await prisma.evbooking.findMany()
     * 
     * // Get first 10 Evbookings
     * const evbookings = await prisma.evbooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evbookingWithIdOnly = await prisma.evbooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvbookingFindManyArgs>(args?: SelectSubset<T, EvbookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evbooking.
     * @param {EvbookingCreateArgs} args - Arguments to create a Evbooking.
     * @example
     * // Create one Evbooking
     * const Evbooking = await prisma.evbooking.create({
     *   data: {
     *     // ... data to create a Evbooking
     *   }
     * })
     * 
     */
    create<T extends EvbookingCreateArgs>(args: SelectSubset<T, EvbookingCreateArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evbookings.
     * @param {EvbookingCreateManyArgs} args - Arguments to create many Evbookings.
     * @example
     * // Create many Evbookings
     * const evbooking = await prisma.evbooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvbookingCreateManyArgs>(args?: SelectSubset<T, EvbookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evbookings and returns the data saved in the database.
     * @param {EvbookingCreateManyAndReturnArgs} args - Arguments to create many Evbookings.
     * @example
     * // Create many Evbookings
     * const evbooking = await prisma.evbooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evbookings and only return the `id`
     * const evbookingWithIdOnly = await prisma.evbooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvbookingCreateManyAndReturnArgs>(args?: SelectSubset<T, EvbookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evbooking.
     * @param {EvbookingDeleteArgs} args - Arguments to delete one Evbooking.
     * @example
     * // Delete one Evbooking
     * const Evbooking = await prisma.evbooking.delete({
     *   where: {
     *     // ... filter to delete one Evbooking
     *   }
     * })
     * 
     */
    delete<T extends EvbookingDeleteArgs>(args: SelectSubset<T, EvbookingDeleteArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evbooking.
     * @param {EvbookingUpdateArgs} args - Arguments to update one Evbooking.
     * @example
     * // Update one Evbooking
     * const evbooking = await prisma.evbooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvbookingUpdateArgs>(args: SelectSubset<T, EvbookingUpdateArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evbookings.
     * @param {EvbookingDeleteManyArgs} args - Arguments to filter Evbookings to delete.
     * @example
     * // Delete a few Evbookings
     * const { count } = await prisma.evbooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvbookingDeleteManyArgs>(args?: SelectSubset<T, EvbookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evbookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evbookings
     * const evbooking = await prisma.evbooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvbookingUpdateManyArgs>(args: SelectSubset<T, EvbookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evbooking.
     * @param {EvbookingUpsertArgs} args - Arguments to update or create a Evbooking.
     * @example
     * // Update or create a Evbooking
     * const evbooking = await prisma.evbooking.upsert({
     *   create: {
     *     // ... data to create a Evbooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evbooking we want to update
     *   }
     * })
     */
    upsert<T extends EvbookingUpsertArgs>(args: SelectSubset<T, EvbookingUpsertArgs<ExtArgs>>): Prisma__EvbookingClient<$Result.GetResult<Prisma.$EvbookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evbookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingCountArgs} args - Arguments to filter Evbookings to count.
     * @example
     * // Count the number of Evbookings
     * const count = await prisma.evbooking.count({
     *   where: {
     *     // ... the filter for the Evbookings we want to count
     *   }
     * })
    **/
    count<T extends EvbookingCountArgs>(
      args?: Subset<T, EvbookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvbookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evbooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvbookingAggregateArgs>(args: Subset<T, EvbookingAggregateArgs>): Prisma.PrismaPromise<GetEvbookingAggregateType<T>>

    /**
     * Group by Evbooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvbookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvbookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvbookingGroupByArgs['orderBy'] }
        : { orderBy?: EvbookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvbookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvbookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evbooking model
   */
  readonly fields: EvbookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evbooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvbookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventsDefaultArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evbooking model
   */ 
  interface EvbookingFieldRefs {
    readonly id: FieldRef<"Evbooking", 'Int'>
    readonly username: FieldRef<"Evbooking", 'String'>
    readonly phoneNumber: FieldRef<"Evbooking", 'String'>
    readonly email: FieldRef<"Evbooking", 'String'>
    readonly address: FieldRef<"Evbooking", 'String'>
    readonly ticketNumber: FieldRef<"Evbooking", 'String'>
    readonly person: FieldRef<"Evbooking", 'Int'>
    readonly price: FieldRef<"Evbooking", 'Int'>
    readonly amount: FieldRef<"Evbooking", 'Float'>
    readonly vat: FieldRef<"Evbooking", 'Float'>
    readonly payStatus: FieldRef<"Evbooking", 'PaymentStatus'>
    readonly eventDate: FieldRef<"Evbooking", 'DateTime'>
    readonly eventId: FieldRef<"Evbooking", 'Int'>
    readonly status: FieldRef<"Evbooking", 'Boolean'>
    readonly optionalData: FieldRef<"Evbooking", 'Json'>
    readonly issueAt: FieldRef<"Evbooking", 'DateTime'>
    readonly deletedAt: FieldRef<"Evbooking", 'DateTime'>
    readonly createdAt: FieldRef<"Evbooking", 'DateTime'>
    readonly updatedAt: FieldRef<"Evbooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evbooking findUnique
   */
  export type EvbookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * Filter, which Evbooking to fetch.
     */
    where: EvbookingWhereUniqueInput
  }

  /**
   * Evbooking findUniqueOrThrow
   */
  export type EvbookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * Filter, which Evbooking to fetch.
     */
    where: EvbookingWhereUniqueInput
  }

  /**
   * Evbooking findFirst
   */
  export type EvbookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * Filter, which Evbooking to fetch.
     */
    where?: EvbookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evbookings to fetch.
     */
    orderBy?: EvbookingOrderByWithRelationInput | EvbookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evbookings.
     */
    cursor?: EvbookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evbookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evbookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evbookings.
     */
    distinct?: EvbookingScalarFieldEnum | EvbookingScalarFieldEnum[]
  }

  /**
   * Evbooking findFirstOrThrow
   */
  export type EvbookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * Filter, which Evbooking to fetch.
     */
    where?: EvbookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evbookings to fetch.
     */
    orderBy?: EvbookingOrderByWithRelationInput | EvbookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evbookings.
     */
    cursor?: EvbookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evbookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evbookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evbookings.
     */
    distinct?: EvbookingScalarFieldEnum | EvbookingScalarFieldEnum[]
  }

  /**
   * Evbooking findMany
   */
  export type EvbookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * Filter, which Evbookings to fetch.
     */
    where?: EvbookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evbookings to fetch.
     */
    orderBy?: EvbookingOrderByWithRelationInput | EvbookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evbookings.
     */
    cursor?: EvbookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evbookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evbookings.
     */
    skip?: number
    distinct?: EvbookingScalarFieldEnum | EvbookingScalarFieldEnum[]
  }

  /**
   * Evbooking create
   */
  export type EvbookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Evbooking.
     */
    data: XOR<EvbookingCreateInput, EvbookingUncheckedCreateInput>
  }

  /**
   * Evbooking createMany
   */
  export type EvbookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evbookings.
     */
    data: EvbookingCreateManyInput | EvbookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evbooking createManyAndReturn
   */
  export type EvbookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Evbookings.
     */
    data: EvbookingCreateManyInput | EvbookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evbooking update
   */
  export type EvbookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Evbooking.
     */
    data: XOR<EvbookingUpdateInput, EvbookingUncheckedUpdateInput>
    /**
     * Choose, which Evbooking to update.
     */
    where: EvbookingWhereUniqueInput
  }

  /**
   * Evbooking updateMany
   */
  export type EvbookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evbookings.
     */
    data: XOR<EvbookingUpdateManyMutationInput, EvbookingUncheckedUpdateManyInput>
    /**
     * Filter which Evbookings to update
     */
    where?: EvbookingWhereInput
  }

  /**
   * Evbooking upsert
   */
  export type EvbookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Evbooking to update in case it exists.
     */
    where: EvbookingWhereUniqueInput
    /**
     * In case the Evbooking found by the `where` argument doesn't exist, create a new Evbooking with this data.
     */
    create: XOR<EvbookingCreateInput, EvbookingUncheckedCreateInput>
    /**
     * In case the Evbooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvbookingUpdateInput, EvbookingUncheckedUpdateInput>
  }

  /**
   * Evbooking delete
   */
  export type EvbookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
    /**
     * Filter which Evbooking to delete.
     */
    where: EvbookingWhereUniqueInput
  }

  /**
   * Evbooking deleteMany
   */
  export type EvbookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evbookings to delete
     */
    where?: EvbookingWhereInput
  }

  /**
   * Evbooking without action
   */
  export type EvbookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evbooking
     */
    select?: EvbookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvbookingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    loggerType: 'loggerType'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OwnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    userType: 'userType',
    ownerId: 'ownerId',
    roleId: 'roleId',
    birthDate: 'birthDate',
    phoneNumber: 'phoneNumber',
    country: 'country',
    city: 'city',
    location: 'location',
    residenceAddress: 'residenceAddress',
    occupation: 'occupation',
    designation: 'designation',
    nid: 'nid',
    tin: 'tin',
    havingBusiness: 'havingBusiness',
    password: 'password',
    loggerType: 'loggerType',
    isVerify: 'isVerify',
    status: 'status',
    deletedAtAt: 'deletedAtAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OwnerScalarFieldEnum = (typeof OwnerScalarFieldEnum)[keyof typeof OwnerScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    userType: 'userType',
    birthDate: 'birthDate',
    phoneNumber: 'phoneNumber',
    picture: 'picture',
    country: 'country',
    city: 'city',
    location: 'location',
    residenceAddress: 'residenceAddress',
    occupation: 'occupation',
    designation: 'designation',
    nid: 'nid',
    tin: 'tin',
    password: 'password',
    otp: 'otp',
    otpExpireAt: 'otpExpireAt',
    isVerify: 'isVerify',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleName: 'roleName',
    permissions: 'permissions',
    branchId: 'branchId',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const WishListScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId',
    propertyId: 'propertyId',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WishListScalarFieldEnum = (typeof WishListScalarFieldEnum)[keyof typeof WishListScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    type: 'type',
    listingName: 'listingName',
    slug: 'slug',
    title: 'title',
    subTitle: 'subTitle',
    logo: 'logo',
    image: 'image',
    description: 'description',
    terms: 'terms',
    slot: 'slot',
    offday: 'offday',
    cuisines: 'cuisines',
    reservationCategory: 'reservationCategory',
    sectSymb: 'sectSymb',
    priority: 'priority',
    optionalData: 'optionalData',
    eventStatus: 'eventStatus',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    propertyId: 'propertyId',
    branchName: 'branchName',
    slug: 'slug',
    images: 'images',
    description: 'description',
    level: 'level',
    terms: 'terms',
    city: 'city',
    area: 'area',
    country: 'country',
    amenities: 'amenities',
    amenity: 'amenity',
    latitude: 'latitude',
    longitude: 'longitude',
    location: 'location',
    optionalData: 'optionalData',
    bookingCount: 'bookingCount',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    type: 'type',
    capacity: 'capacity',
    position: 'position',
    size: 'size',
    image: 'image',
    splitable: 'splitable',
    ryservable: 'ryservable',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const SeatBedScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    type: 'type',
    roomNo: 'roomNo',
    breakfast: 'breakfast',
    image: 'image',
    accomodationCapacity: 'accomodationCapacity',
    extraBedPolicy: 'extraBedPolicy',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeatBedScalarFieldEnum = (typeof SeatBedScalarFieldEnum)[keyof typeof SeatBedScalarFieldEnum]


  export const FoodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    images: 'images',
    optionalData: 'optionalData',
    rating: 'rating',
    propertyId: 'propertyId',
    price: 'price',
    description: 'description',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodScalarFieldEnum = (typeof FoodScalarFieldEnum)[keyof typeof FoodScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    subtitle: 'subtitle',
    pattern: 'pattern',
    contains: 'contains',
    signature: 'signature',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    branchId: 'branchId',
    location: 'location',
    mapLocation: 'mapLocation',
    address: 'address',
    capacity: 'capacity',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    branchId: 'branchId',
    tableId: 'tableId',
    seatBedId: 'seatBedId',
    ownerId: 'ownerId',
    customerId: 'customerId',
    customerName: 'customerName',
    phoneNumber: 'phoneNumber',
    startDate: 'startDate',
    endDate: 'endDate',
    slot: 'slot',
    comment: 'comment',
    customerRequest: 'customerRequest',
    cancelReason: 'cancelReason',
    guestNumber: 'guestNumber',
    amount: 'amount',
    vat: 'vat',
    discount: 'discount',
    grandTotal: 'grandTotal',
    status: 'status',
    bookingType: 'bookingType',
    optionalData: 'optionalData',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    paymentDate: 'paymentDate',
    paymentInfo: 'paymentInfo',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AmenitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    price: 'price',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmenitiesScalarFieldEnum = (typeof AmenitiesScalarFieldEnum)[keyof typeof AmenitiesScalarFieldEnum]


  export const CuisineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CuisineScalarFieldEnum = (typeof CuisineScalarFieldEnum)[keyof typeof CuisineScalarFieldEnum]


  export const EvbookingScalarFieldEnum: {
    id: 'id',
    username: 'username',
    phoneNumber: 'phoneNumber',
    email: 'email',
    address: 'address',
    ticketNumber: 'ticketNumber',
    person: 'person',
    price: 'price',
    amount: 'amount',
    vat: 'vat',
    payStatus: 'payStatus',
    eventDate: 'eventDate',
    eventId: 'eventId',
    status: 'status',
    optionalData: 'optionalData',
    issueAt: 'issueAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvbookingScalarFieldEnum = (typeof EvbookingScalarFieldEnum)[keyof typeof EvbookingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SessionOrderByRelevanceFieldEnum: {
    sessionToken: 'sessionToken'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const OwnerOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    country: 'country',
    city: 'city',
    location: 'location',
    residenceAddress: 'residenceAddress',
    occupation: 'occupation',
    designation: 'designation',
    nid: 'nid',
    tin: 'tin',
    password: 'password'
  };

  export type OwnerOrderByRelevanceFieldEnum = (typeof OwnerOrderByRelevanceFieldEnum)[keyof typeof OwnerOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    phoneNumber: 'phoneNumber',
    picture: 'picture',
    country: 'country',
    city: 'city',
    location: 'location',
    residenceAddress: 'residenceAddress',
    occupation: 'occupation',
    designation: 'designation',
    tin: 'tin',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RolePermissionOrderByRelevanceFieldEnum: {
    roleName: 'roleName',
    permissions: 'permissions'
  };

  export type RolePermissionOrderByRelevanceFieldEnum = (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const PropertyOrderByRelevanceFieldEnum: {
    listingName: 'listingName',
    slug: 'slug',
    title: 'title',
    subTitle: 'subTitle',
    logo: 'logo',
    description: 'description',
    terms: 'terms',
    cuisines: 'cuisines'
  };

  export type PropertyOrderByRelevanceFieldEnum = (typeof PropertyOrderByRelevanceFieldEnum)[keyof typeof PropertyOrderByRelevanceFieldEnum]


  export const BranchOrderByRelevanceFieldEnum: {
    branchName: 'branchName',
    slug: 'slug',
    description: 'description',
    level: 'level',
    terms: 'terms',
    city: 'city',
    area: 'area',
    country: 'country',
    amenity: 'amenity',
    latitude: 'latitude',
    longitude: 'longitude',
    location: 'location'
  };

  export type BranchOrderByRelevanceFieldEnum = (typeof BranchOrderByRelevanceFieldEnum)[keyof typeof BranchOrderByRelevanceFieldEnum]


  export const TableOrderByRelevanceFieldEnum: {
    position: 'position',
    size: 'size',
    image: 'image'
  };

  export type TableOrderByRelevanceFieldEnum = (typeof TableOrderByRelevanceFieldEnum)[keyof typeof TableOrderByRelevanceFieldEnum]


  export const SeatBedOrderByRelevanceFieldEnum: {
    roomNo: 'roomNo',
    breakfast: 'breakfast',
    image: 'image',
    accomodationCapacity: 'accomodationCapacity',
    extraBedPolicy: 'extraBedPolicy'
  };

  export type SeatBedOrderByRelevanceFieldEnum = (typeof SeatBedOrderByRelevanceFieldEnum)[keyof typeof SeatBedOrderByRelevanceFieldEnum]


  export const FoodOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type FoodOrderByRelevanceFieldEnum = (typeof FoodOrderByRelevanceFieldEnum)[keyof typeof FoodOrderByRelevanceFieldEnum]


  export const SectionOrderByRelevanceFieldEnum: {
    title: 'title',
    slug: 'slug',
    subtitle: 'subtitle',
    pattern: 'pattern'
  };

  export type SectionOrderByRelevanceFieldEnum = (typeof SectionOrderByRelevanceFieldEnum)[keyof typeof SectionOrderByRelevanceFieldEnum]


  export const EventsOrderByRelevanceFieldEnum: {
    location: 'location',
    mapLocation: 'mapLocation',
    address: 'address'
  };

  export type EventsOrderByRelevanceFieldEnum = (typeof EventsOrderByRelevanceFieldEnum)[keyof typeof EventsOrderByRelevanceFieldEnum]


  export const BookingOrderByRelevanceFieldEnum: {
    customerName: 'customerName',
    phoneNumber: 'phoneNumber',
    slot: 'slot',
    comment: 'comment',
    customerRequest: 'customerRequest',
    cancelReason: 'cancelReason',
    bookingType: 'bookingType'
  };

  export type BookingOrderByRelevanceFieldEnum = (typeof BookingOrderByRelevanceFieldEnum)[keyof typeof BookingOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    paymentInfo: 'paymentInfo'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const AmenitiesOrderByRelevanceFieldEnum: {
    name: 'name',
    icon: 'icon'
  };

  export type AmenitiesOrderByRelevanceFieldEnum = (typeof AmenitiesOrderByRelevanceFieldEnum)[keyof typeof AmenitiesOrderByRelevanceFieldEnum]


  export const CuisineOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CuisineOrderByRelevanceFieldEnum = (typeof CuisineOrderByRelevanceFieldEnum)[keyof typeof CuisineOrderByRelevanceFieldEnum]


  export const EvbookingOrderByRelevanceFieldEnum: {
    username: 'username',
    phoneNumber: 'phoneNumber',
    email: 'email',
    address: 'address',
    ticketNumber: 'ticketNumber'
  };

  export type EvbookingOrderByRelevanceFieldEnum = (typeof EvbookingOrderByRelevanceFieldEnum)[keyof typeof EvbookingOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'loggerType'
   */
  export type EnumloggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'loggerType'>
    


  /**
   * Reference to a field of type 'loggerType[]'
   */
  export type ListEnumloggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'loggerType[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BusinessCategory'
   */
  export type EnumBusinessCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessCategory'>
    


  /**
   * Reference to a field of type 'BusinessCategory[]'
   */
  export type ListEnumBusinessCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessCategory[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'compType'
   */
  export type EnumcompTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'compType'>
    


  /**
   * Reference to a field of type 'compType[]'
   */
  export type ListEnumcompTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'compType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntNullableFilter<"Session"> | number | null
    expires?: DateTimeFilter<"Session"> | Date | string
    loggerType?: EnumloggerTypeNullableFilter<"Session"> | $Enums.loggerType | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrderInput | SortOrder
    expires?: SortOrder
    loggerType?: SortOrderInput | SortOrder
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntNullableFilter<"Session"> | number | null
    expires?: DateTimeFilter<"Session"> | Date | string
    loggerType?: EnumloggerTypeNullableFilter<"Session"> | $Enums.loggerType | null
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrderInput | SortOrder
    expires?: SortOrder
    loggerType?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntNullableWithAggregatesFilter<"Session"> | number | null
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    loggerType?: EnumloggerTypeNullableWithAggregatesFilter<"Session"> | $Enums.loggerType | null
  }

  export type OwnerWhereInput = {
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    id?: IntFilter<"Owner"> | number
    name?: StringNullableFilter<"Owner"> | string | null
    email?: StringNullableFilter<"Owner"> | string | null
    userType?: EnumUserTypeNullableFilter<"Owner"> | $Enums.UserType | null
    ownerId?: IntNullableFilter<"Owner"> | number | null
    roleId?: IntNullableFilter<"Owner"> | number | null
    birthDate?: DateTimeNullableFilter<"Owner"> | Date | string | null
    phoneNumber?: StringNullableFilter<"Owner"> | string | null
    country?: StringNullableFilter<"Owner"> | string | null
    city?: StringNullableFilter<"Owner"> | string | null
    location?: StringNullableFilter<"Owner"> | string | null
    residenceAddress?: StringNullableFilter<"Owner"> | string | null
    occupation?: StringNullableFilter<"Owner"> | string | null
    designation?: StringNullableFilter<"Owner"> | string | null
    nid?: StringNullableFilter<"Owner"> | string | null
    tin?: StringNullableFilter<"Owner"> | string | null
    havingBusiness?: BoolNullableFilter<"Owner"> | boolean | null
    password?: StringNullableFilter<"Owner"> | string | null
    loggerType?: EnumloggerTypeNullableFilter<"Owner"> | $Enums.loggerType | null
    isVerify?: BoolFilter<"Owner"> | boolean
    status?: BoolFilter<"Owner"> | boolean
    deletedAtAt?: DateTimeNullableFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    updatedAt?: DateTimeFilter<"Owner"> | Date | string
    roles?: XOR<RolePermissionNullableRelationFilter, RolePermissionWhereInput> | null
    branch?: BranchListRelationFilter
    property?: PropertyListRelationFilter
    booking?: BookingListRelationFilter
  }

  export type OwnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    userType?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    residenceAddress?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    nid?: SortOrderInput | SortOrder
    tin?: SortOrderInput | SortOrder
    havingBusiness?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    loggerType?: SortOrderInput | SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAtAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: RolePermissionOrderByWithRelationInput
    branch?: BranchOrderByRelationAggregateInput
    property?: PropertyOrderByRelationAggregateInput
    booking?: BookingOrderByRelationAggregateInput
    _relevance?: OwnerOrderByRelevanceInput
  }

  export type OwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    name?: StringNullableFilter<"Owner"> | string | null
    userType?: EnumUserTypeNullableFilter<"Owner"> | $Enums.UserType | null
    ownerId?: IntNullableFilter<"Owner"> | number | null
    roleId?: IntNullableFilter<"Owner"> | number | null
    birthDate?: DateTimeNullableFilter<"Owner"> | Date | string | null
    phoneNumber?: StringNullableFilter<"Owner"> | string | null
    country?: StringNullableFilter<"Owner"> | string | null
    city?: StringNullableFilter<"Owner"> | string | null
    location?: StringNullableFilter<"Owner"> | string | null
    residenceAddress?: StringNullableFilter<"Owner"> | string | null
    occupation?: StringNullableFilter<"Owner"> | string | null
    designation?: StringNullableFilter<"Owner"> | string | null
    nid?: StringNullableFilter<"Owner"> | string | null
    tin?: StringNullableFilter<"Owner"> | string | null
    havingBusiness?: BoolNullableFilter<"Owner"> | boolean | null
    password?: StringNullableFilter<"Owner"> | string | null
    loggerType?: EnumloggerTypeNullableFilter<"Owner"> | $Enums.loggerType | null
    isVerify?: BoolFilter<"Owner"> | boolean
    status?: BoolFilter<"Owner"> | boolean
    deletedAtAt?: DateTimeNullableFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    updatedAt?: DateTimeFilter<"Owner"> | Date | string
    roles?: XOR<RolePermissionNullableRelationFilter, RolePermissionWhereInput> | null
    branch?: BranchListRelationFilter
    property?: PropertyListRelationFilter
    booking?: BookingListRelationFilter
  }, "id" | "email">

  export type OwnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    userType?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    residenceAddress?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    nid?: SortOrderInput | SortOrder
    tin?: SortOrderInput | SortOrder
    havingBusiness?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    loggerType?: SortOrderInput | SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAtAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OwnerCountOrderByAggregateInput
    _avg?: OwnerAvgOrderByAggregateInput
    _max?: OwnerMaxOrderByAggregateInput
    _min?: OwnerMinOrderByAggregateInput
    _sum?: OwnerSumOrderByAggregateInput
  }

  export type OwnerScalarWhereWithAggregatesInput = {
    AND?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    OR?: OwnerScalarWhereWithAggregatesInput[]
    NOT?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Owner"> | number
    name?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    email?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    userType?: EnumUserTypeNullableWithAggregatesFilter<"Owner"> | $Enums.UserType | null
    ownerId?: IntNullableWithAggregatesFilter<"Owner"> | number | null
    roleId?: IntNullableWithAggregatesFilter<"Owner"> | number | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Owner"> | Date | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    country?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    city?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    location?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    residenceAddress?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    designation?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    nid?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    tin?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    havingBusiness?: BoolNullableWithAggregatesFilter<"Owner"> | boolean | null
    password?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    loggerType?: EnumloggerTypeNullableWithAggregatesFilter<"Owner"> | $Enums.loggerType | null
    isVerify?: BoolWithAggregatesFilter<"Owner"> | boolean
    status?: BoolWithAggregatesFilter<"Owner"> | boolean
    deletedAtAt?: DateTimeNullableWithAggregatesFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    userType?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    picture?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    residenceAddress?: StringNullableFilter<"User"> | string | null
    occupation?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    nid?: IntNullableFilter<"User"> | number | null
    tin?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    otp?: IntNullableFilter<"User"> | number | null
    otpExpireAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerify?: BoolFilter<"User"> | boolean
    status?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    booking?: BookingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    userType?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    residenceAddress?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    nid?: SortOrderInput | SortOrder
    tin?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpireAt?: SortOrderInput | SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    userType?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    picture?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    residenceAddress?: StringNullableFilter<"User"> | string | null
    occupation?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    nid?: IntNullableFilter<"User"> | number | null
    tin?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    otp?: IntNullableFilter<"User"> | number | null
    otpExpireAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerify?: BoolFilter<"User"> | boolean
    status?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    booking?: BookingListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    userType?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    residenceAddress?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    nid?: SortOrderInput | SortOrder
    tin?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpireAt?: SortOrderInput | SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    userType?: EnumUserTypeNullableWithAggregatesFilter<"User"> | $Enums.UserType | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    picture?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    residenceAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"User"> | string | null
    designation?: StringNullableWithAggregatesFilter<"User"> | string | null
    nid?: IntNullableWithAggregatesFilter<"User"> | number | null
    tin?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    otp?: IntNullableWithAggregatesFilter<"User"> | number | null
    otpExpireAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerify?: BoolWithAggregatesFilter<"User"> | boolean
    status?: BoolWithAggregatesFilter<"User"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleName?: StringFilter<"RolePermission"> | string
    permissions?: StringNullableListFilter<"RolePermission">
    branchId?: IntFilter<"RolePermission"> | number
    status?: BoolFilter<"RolePermission"> | boolean
    deletedAt?: DateTimeNullableFilter<"RolePermission"> | Date | string | null
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    owner?: OwnerListRelationFilter
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissions?: SortOrder
    branchId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    owner?: OwnerOrderByRelationAggregateInput
    _relevance?: RolePermissionOrderByRelevanceInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleName?: StringFilter<"RolePermission"> | string
    permissions?: StringNullableListFilter<"RolePermission">
    branchId?: IntFilter<"RolePermission"> | number
    status?: BoolFilter<"RolePermission"> | boolean
    deletedAt?: DateTimeNullableFilter<"RolePermission"> | Date | string | null
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    owner?: OwnerListRelationFilter
  }, "id">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissions?: SortOrder
    branchId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleName?: StringWithAggregatesFilter<"RolePermission"> | string
    permissions?: StringNullableListFilter<"RolePermission">
    branchId?: IntWithAggregatesFilter<"RolePermission"> | number
    status?: BoolWithAggregatesFilter<"RolePermission"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RolePermission"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type wishListWhereInput = {
    AND?: wishListWhereInput | wishListWhereInput[]
    OR?: wishListWhereInput[]
    NOT?: wishListWhereInput | wishListWhereInput[]
    id?: IntFilter<"wishList"> | number
    type?: EnumBusinessCategoryNullableFilter<"wishList"> | $Enums.BusinessCategory | null
    userId?: IntNullableFilter<"wishList"> | number | null
    propertyId?: IntNullableFilter<"wishList"> | number | null
    status?: BoolFilter<"wishList"> | boolean
    deletedAt?: DateTimeNullableFilter<"wishList"> | Date | string | null
    createdAt?: DateTimeFilter<"wishList"> | Date | string
    updatedAt?: DateTimeFilter<"wishList"> | Date | string
    Property?: XOR<PropertyNullableRelationFilter, PropertyWhereInput> | null
  }

  export type wishListOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Property?: PropertyOrderByWithRelationInput
  }

  export type wishListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wishListWhereInput | wishListWhereInput[]
    OR?: wishListWhereInput[]
    NOT?: wishListWhereInput | wishListWhereInput[]
    type?: EnumBusinessCategoryNullableFilter<"wishList"> | $Enums.BusinessCategory | null
    userId?: IntNullableFilter<"wishList"> | number | null
    propertyId?: IntNullableFilter<"wishList"> | number | null
    status?: BoolFilter<"wishList"> | boolean
    deletedAt?: DateTimeNullableFilter<"wishList"> | Date | string | null
    createdAt?: DateTimeFilter<"wishList"> | Date | string
    updatedAt?: DateTimeFilter<"wishList"> | Date | string
    Property?: XOR<PropertyNullableRelationFilter, PropertyWhereInput> | null
  }, "id">

  export type wishListOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: wishListCountOrderByAggregateInput
    _avg?: wishListAvgOrderByAggregateInput
    _max?: wishListMaxOrderByAggregateInput
    _min?: wishListMinOrderByAggregateInput
    _sum?: wishListSumOrderByAggregateInput
  }

  export type wishListScalarWhereWithAggregatesInput = {
    AND?: wishListScalarWhereWithAggregatesInput | wishListScalarWhereWithAggregatesInput[]
    OR?: wishListScalarWhereWithAggregatesInput[]
    NOT?: wishListScalarWhereWithAggregatesInput | wishListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wishList"> | number
    type?: EnumBusinessCategoryNullableWithAggregatesFilter<"wishList"> | $Enums.BusinessCategory | null
    userId?: IntNullableWithAggregatesFilter<"wishList"> | number | null
    propertyId?: IntNullableWithAggregatesFilter<"wishList"> | number | null
    status?: BoolWithAggregatesFilter<"wishList"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"wishList"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"wishList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"wishList"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: IntFilter<"Property"> | number
    ownerId?: IntFilter<"Property"> | number
    type?: EnumBusinessCategoryNullableFilter<"Property"> | $Enums.BusinessCategory | null
    listingName?: StringFilter<"Property"> | string
    slug?: StringNullableFilter<"Property"> | string | null
    title?: StringNullableFilter<"Property"> | string | null
    subTitle?: StringNullableFilter<"Property"> | string | null
    logo?: StringNullableFilter<"Property"> | string | null
    image?: JsonNullableFilter<"Property">
    description?: StringNullableFilter<"Property"> | string | null
    terms?: StringNullableFilter<"Property"> | string | null
    slot?: JsonNullableFilter<"Property">
    offday?: JsonNullableFilter<"Property">
    cuisines?: StringNullableListFilter<"Property">
    reservationCategory?: EnumCategoryNullableFilter<"Property"> | $Enums.Category | null
    sectSymb?: IntNullableFilter<"Property"> | number | null
    priority?: IntNullableFilter<"Property"> | number | null
    optionalData?: JsonNullableFilter<"Property">
    eventStatus?: BoolFilter<"Property"> | boolean
    status?: BoolFilter<"Property"> | boolean
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    owner?: XOR<OwnerRelationFilter, OwnerWhereInput>
    tables?: TableListRelationFilter
    seatBed?: SeatBedListRelationFilter
    booking?: BookingListRelationFilter
    wishLists?: WishListListRelationFilter
    food?: FoodListRelationFilter
    branches?: BranchListRelationFilter
    event?: EventsListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrderInput | SortOrder
    listingName?: SortOrder
    slug?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    subTitle?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    slot?: SortOrderInput | SortOrder
    offday?: SortOrderInput | SortOrder
    cuisines?: SortOrder
    reservationCategory?: SortOrderInput | SortOrder
    sectSymb?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    eventStatus?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: OwnerOrderByWithRelationInput
    tables?: TableOrderByRelationAggregateInput
    seatBed?: SeatBedOrderByRelationAggregateInput
    booking?: BookingOrderByRelationAggregateInput
    wishLists?: wishListOrderByRelationAggregateInput
    food?: FoodOrderByRelationAggregateInput
    branches?: BranchOrderByRelationAggregateInput
    event?: EventsOrderByRelationAggregateInput
    _relevance?: PropertyOrderByRelevanceInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    ownerId?: IntFilter<"Property"> | number
    type?: EnumBusinessCategoryNullableFilter<"Property"> | $Enums.BusinessCategory | null
    listingName?: StringFilter<"Property"> | string
    slug?: StringNullableFilter<"Property"> | string | null
    title?: StringNullableFilter<"Property"> | string | null
    subTitle?: StringNullableFilter<"Property"> | string | null
    logo?: StringNullableFilter<"Property"> | string | null
    image?: JsonNullableFilter<"Property">
    description?: StringNullableFilter<"Property"> | string | null
    terms?: StringNullableFilter<"Property"> | string | null
    slot?: JsonNullableFilter<"Property">
    offday?: JsonNullableFilter<"Property">
    cuisines?: StringNullableListFilter<"Property">
    reservationCategory?: EnumCategoryNullableFilter<"Property"> | $Enums.Category | null
    sectSymb?: IntNullableFilter<"Property"> | number | null
    priority?: IntNullableFilter<"Property"> | number | null
    optionalData?: JsonNullableFilter<"Property">
    eventStatus?: BoolFilter<"Property"> | boolean
    status?: BoolFilter<"Property"> | boolean
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    owner?: XOR<OwnerRelationFilter, OwnerWhereInput>
    tables?: TableListRelationFilter
    seatBed?: SeatBedListRelationFilter
    booking?: BookingListRelationFilter
    wishLists?: WishListListRelationFilter
    food?: FoodListRelationFilter
    branches?: BranchListRelationFilter
    event?: EventsListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrderInput | SortOrder
    listingName?: SortOrder
    slug?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    subTitle?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    slot?: SortOrderInput | SortOrder
    offday?: SortOrderInput | SortOrder
    cuisines?: SortOrder
    reservationCategory?: SortOrderInput | SortOrder
    sectSymb?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    eventStatus?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Property"> | number
    ownerId?: IntWithAggregatesFilter<"Property"> | number
    type?: EnumBusinessCategoryNullableWithAggregatesFilter<"Property"> | $Enums.BusinessCategory | null
    listingName?: StringWithAggregatesFilter<"Property"> | string
    slug?: StringNullableWithAggregatesFilter<"Property"> | string | null
    title?: StringNullableWithAggregatesFilter<"Property"> | string | null
    subTitle?: StringNullableWithAggregatesFilter<"Property"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Property"> | string | null
    image?: JsonNullableWithAggregatesFilter<"Property">
    description?: StringNullableWithAggregatesFilter<"Property"> | string | null
    terms?: StringNullableWithAggregatesFilter<"Property"> | string | null
    slot?: JsonNullableWithAggregatesFilter<"Property">
    offday?: JsonNullableWithAggregatesFilter<"Property">
    cuisines?: StringNullableListFilter<"Property">
    reservationCategory?: EnumCategoryNullableWithAggregatesFilter<"Property"> | $Enums.Category | null
    sectSymb?: IntNullableWithAggregatesFilter<"Property"> | number | null
    priority?: IntNullableWithAggregatesFilter<"Property"> | number | null
    optionalData?: JsonNullableWithAggregatesFilter<"Property">
    eventStatus?: BoolWithAggregatesFilter<"Property"> | boolean
    status?: BoolWithAggregatesFilter<"Property"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    ownerId?: IntFilter<"Branch"> | number
    propertyId?: IntFilter<"Branch"> | number
    branchName?: StringNullableFilter<"Branch"> | string | null
    slug?: StringNullableFilter<"Branch"> | string | null
    images?: JsonNullableFilter<"Branch">
    description?: StringNullableFilter<"Branch"> | string | null
    level?: StringNullableFilter<"Branch"> | string | null
    terms?: StringNullableFilter<"Branch"> | string | null
    city?: StringNullableFilter<"Branch"> | string | null
    area?: StringNullableFilter<"Branch"> | string | null
    country?: StringNullableFilter<"Branch"> | string | null
    amenities?: JsonNullableFilter<"Branch">
    amenity?: StringNullableListFilter<"Branch">
    latitude?: StringNullableFilter<"Branch"> | string | null
    longitude?: StringNullableFilter<"Branch"> | string | null
    location?: StringNullableFilter<"Branch"> | string | null
    optionalData?: JsonNullableFilter<"Branch">
    bookingCount?: IntFilter<"Branch"> | number
    status?: BoolFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    owner?: XOR<OwnerRelationFilter, OwnerWhereInput>
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    booking?: BookingListRelationFilter
    events?: EventsListRelationFilter
    rolePermission?: RolePermissionListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    branchName?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    amenities?: SortOrderInput | SortOrder
    amenity?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    bookingCount?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: OwnerOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
    booking?: BookingOrderByRelationAggregateInput
    events?: EventsOrderByRelationAggregateInput
    rolePermission?: RolePermissionOrderByRelationAggregateInput
    _relevance?: BranchOrderByRelevanceInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    ownerId?: IntFilter<"Branch"> | number
    propertyId?: IntFilter<"Branch"> | number
    branchName?: StringNullableFilter<"Branch"> | string | null
    slug?: StringNullableFilter<"Branch"> | string | null
    images?: JsonNullableFilter<"Branch">
    description?: StringNullableFilter<"Branch"> | string | null
    level?: StringNullableFilter<"Branch"> | string | null
    terms?: StringNullableFilter<"Branch"> | string | null
    city?: StringNullableFilter<"Branch"> | string | null
    area?: StringNullableFilter<"Branch"> | string | null
    country?: StringNullableFilter<"Branch"> | string | null
    amenities?: JsonNullableFilter<"Branch">
    amenity?: StringNullableListFilter<"Branch">
    latitude?: StringNullableFilter<"Branch"> | string | null
    longitude?: StringNullableFilter<"Branch"> | string | null
    location?: StringNullableFilter<"Branch"> | string | null
    optionalData?: JsonNullableFilter<"Branch">
    bookingCount?: IntFilter<"Branch"> | number
    status?: BoolFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    owner?: XOR<OwnerRelationFilter, OwnerWhereInput>
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    booking?: BookingListRelationFilter
    events?: EventsListRelationFilter
    rolePermission?: RolePermissionListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    branchName?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    amenities?: SortOrderInput | SortOrder
    amenity?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    bookingCount?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    ownerId?: IntWithAggregatesFilter<"Branch"> | number
    propertyId?: IntWithAggregatesFilter<"Branch"> | number
    branchName?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    slug?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    images?: JsonNullableWithAggregatesFilter<"Branch">
    description?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    level?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    terms?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    city?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    area?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    country?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    amenities?: JsonNullableWithAggregatesFilter<"Branch">
    amenity?: StringNullableListFilter<"Branch">
    latitude?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    longitude?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    location?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    optionalData?: JsonNullableWithAggregatesFilter<"Branch">
    bookingCount?: IntWithAggregatesFilter<"Branch"> | number
    status?: BoolWithAggregatesFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Branch"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: IntFilter<"Table"> | number
    propertyId?: IntFilter<"Table"> | number
    type?: EnumcompTypeNullableFilter<"Table"> | $Enums.compType | null
    capacity?: IntNullableFilter<"Table"> | number | null
    position?: StringFilter<"Table"> | string
    size?: StringFilter<"Table"> | string
    image?: StringNullableFilter<"Table"> | string | null
    splitable?: BoolFilter<"Table"> | boolean
    ryservable?: BoolFilter<"Table"> | boolean
    status?: BoolFilter<"Table"> | boolean
    deletedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    Property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    booking?: BookingListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    position?: SortOrder
    size?: SortOrder
    image?: SortOrderInput | SortOrder
    splitable?: SortOrder
    ryservable?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Property?: PropertyOrderByWithRelationInput
    booking?: BookingOrderByRelationAggregateInput
    _relevance?: TableOrderByRelevanceInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    propertyId?: IntFilter<"Table"> | number
    type?: EnumcompTypeNullableFilter<"Table"> | $Enums.compType | null
    capacity?: IntNullableFilter<"Table"> | number | null
    position?: StringFilter<"Table"> | string
    size?: StringFilter<"Table"> | string
    image?: StringNullableFilter<"Table"> | string | null
    splitable?: BoolFilter<"Table"> | boolean
    ryservable?: BoolFilter<"Table"> | boolean
    status?: BoolFilter<"Table"> | boolean
    deletedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    Property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    booking?: BookingListRelationFilter
  }, "id">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    position?: SortOrder
    size?: SortOrder
    image?: SortOrderInput | SortOrder
    splitable?: SortOrder
    ryservable?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TableCountOrderByAggregateInput
    _avg?: TableAvgOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
    _sum?: TableSumOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Table"> | number
    propertyId?: IntWithAggregatesFilter<"Table"> | number
    type?: EnumcompTypeNullableWithAggregatesFilter<"Table"> | $Enums.compType | null
    capacity?: IntNullableWithAggregatesFilter<"Table"> | number | null
    position?: StringWithAggregatesFilter<"Table"> | string
    size?: StringWithAggregatesFilter<"Table"> | string
    image?: StringNullableWithAggregatesFilter<"Table"> | string | null
    splitable?: BoolWithAggregatesFilter<"Table"> | boolean
    ryservable?: BoolWithAggregatesFilter<"Table"> | boolean
    status?: BoolWithAggregatesFilter<"Table"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Table"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
  }

  export type SeatBedWhereInput = {
    AND?: SeatBedWhereInput | SeatBedWhereInput[]
    OR?: SeatBedWhereInput[]
    NOT?: SeatBedWhereInput | SeatBedWhereInput[]
    id?: IntFilter<"SeatBed"> | number
    propertyId?: IntFilter<"SeatBed"> | number
    type?: EnumcompTypeNullableFilter<"SeatBed"> | $Enums.compType | null
    roomNo?: StringFilter<"SeatBed"> | string
    breakfast?: StringFilter<"SeatBed"> | string
    image?: StringNullableFilter<"SeatBed"> | string | null
    accomodationCapacity?: StringFilter<"SeatBed"> | string
    extraBedPolicy?: StringFilter<"SeatBed"> | string
    status?: BoolFilter<"SeatBed"> | boolean
    deletedAt?: DateTimeNullableFilter<"SeatBed"> | Date | string | null
    createdAt?: DateTimeFilter<"SeatBed"> | Date | string
    updatedAt?: DateTimeFilter<"SeatBed"> | Date | string
    Property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    booking?: BookingListRelationFilter
  }

  export type SeatBedOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrderInput | SortOrder
    roomNo?: SortOrder
    breakfast?: SortOrder
    image?: SortOrderInput | SortOrder
    accomodationCapacity?: SortOrder
    extraBedPolicy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Property?: PropertyOrderByWithRelationInput
    booking?: BookingOrderByRelationAggregateInput
    _relevance?: SeatBedOrderByRelevanceInput
  }

  export type SeatBedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeatBedWhereInput | SeatBedWhereInput[]
    OR?: SeatBedWhereInput[]
    NOT?: SeatBedWhereInput | SeatBedWhereInput[]
    propertyId?: IntFilter<"SeatBed"> | number
    type?: EnumcompTypeNullableFilter<"SeatBed"> | $Enums.compType | null
    roomNo?: StringFilter<"SeatBed"> | string
    breakfast?: StringFilter<"SeatBed"> | string
    image?: StringNullableFilter<"SeatBed"> | string | null
    accomodationCapacity?: StringFilter<"SeatBed"> | string
    extraBedPolicy?: StringFilter<"SeatBed"> | string
    status?: BoolFilter<"SeatBed"> | boolean
    deletedAt?: DateTimeNullableFilter<"SeatBed"> | Date | string | null
    createdAt?: DateTimeFilter<"SeatBed"> | Date | string
    updatedAt?: DateTimeFilter<"SeatBed"> | Date | string
    Property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    booking?: BookingListRelationFilter
  }, "id">

  export type SeatBedOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrderInput | SortOrder
    roomNo?: SortOrder
    breakfast?: SortOrder
    image?: SortOrderInput | SortOrder
    accomodationCapacity?: SortOrder
    extraBedPolicy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeatBedCountOrderByAggregateInput
    _avg?: SeatBedAvgOrderByAggregateInput
    _max?: SeatBedMaxOrderByAggregateInput
    _min?: SeatBedMinOrderByAggregateInput
    _sum?: SeatBedSumOrderByAggregateInput
  }

  export type SeatBedScalarWhereWithAggregatesInput = {
    AND?: SeatBedScalarWhereWithAggregatesInput | SeatBedScalarWhereWithAggregatesInput[]
    OR?: SeatBedScalarWhereWithAggregatesInput[]
    NOT?: SeatBedScalarWhereWithAggregatesInput | SeatBedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeatBed"> | number
    propertyId?: IntWithAggregatesFilter<"SeatBed"> | number
    type?: EnumcompTypeNullableWithAggregatesFilter<"SeatBed"> | $Enums.compType | null
    roomNo?: StringWithAggregatesFilter<"SeatBed"> | string
    breakfast?: StringWithAggregatesFilter<"SeatBed"> | string
    image?: StringNullableWithAggregatesFilter<"SeatBed"> | string | null
    accomodationCapacity?: StringWithAggregatesFilter<"SeatBed"> | string
    extraBedPolicy?: StringWithAggregatesFilter<"SeatBed"> | string
    status?: BoolWithAggregatesFilter<"SeatBed"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SeatBed"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SeatBed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeatBed"> | Date | string
  }

  export type FoodWhereInput = {
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    id?: IntFilter<"Food"> | number
    name?: StringFilter<"Food"> | string
    images?: JsonNullableFilter<"Food">
    optionalData?: JsonNullableFilter<"Food">
    rating?: FloatFilter<"Food"> | number
    propertyId?: IntFilter<"Food"> | number
    price?: JsonNullableFilter<"Food">
    description?: StringNullableFilter<"Food"> | string | null
    status?: BoolFilter<"Food"> | boolean
    deletedAt?: DateTimeNullableFilter<"Food"> | Date | string | null
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }

  export type FoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
    price?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    _relevance?: FoodOrderByRelevanceInput
  }

  export type FoodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    name?: StringFilter<"Food"> | string
    images?: JsonNullableFilter<"Food">
    optionalData?: JsonNullableFilter<"Food">
    rating?: FloatFilter<"Food"> | number
    propertyId?: IntFilter<"Food"> | number
    price?: JsonNullableFilter<"Food">
    description?: StringNullableFilter<"Food"> | string | null
    status?: BoolFilter<"Food"> | boolean
    deletedAt?: DateTimeNullableFilter<"Food"> | Date | string | null
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }, "id">

  export type FoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
    price?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodCountOrderByAggregateInput
    _avg?: FoodAvgOrderByAggregateInput
    _max?: FoodMaxOrderByAggregateInput
    _min?: FoodMinOrderByAggregateInput
    _sum?: FoodSumOrderByAggregateInput
  }

  export type FoodScalarWhereWithAggregatesInput = {
    AND?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    OR?: FoodScalarWhereWithAggregatesInput[]
    NOT?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Food"> | number
    name?: StringWithAggregatesFilter<"Food"> | string
    images?: JsonNullableWithAggregatesFilter<"Food">
    optionalData?: JsonNullableWithAggregatesFilter<"Food">
    rating?: FloatWithAggregatesFilter<"Food"> | number
    propertyId?: IntWithAggregatesFilter<"Food"> | number
    price?: JsonNullableWithAggregatesFilter<"Food">
    description?: StringNullableWithAggregatesFilter<"Food"> | string | null
    status?: BoolWithAggregatesFilter<"Food"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Food"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Food"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Food"> | Date | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: IntFilter<"Section"> | number
    title?: StringFilter<"Section"> | string
    slug?: StringNullableFilter<"Section"> | string | null
    subtitle?: StringNullableFilter<"Section"> | string | null
    pattern?: StringFilter<"Section"> | string
    contains?: EnumContentTypeFilter<"Section"> | $Enums.ContentType
    signature?: IntFilter<"Section"> | number
    status?: BoolFilter<"Section"> | boolean
    deletedAt?: DateTimeNullableFilter<"Section"> | Date | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    pattern?: SortOrder
    contains?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SectionOrderByRelevanceInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    title?: StringFilter<"Section"> | string
    slug?: StringNullableFilter<"Section"> | string | null
    subtitle?: StringNullableFilter<"Section"> | string | null
    pattern?: StringFilter<"Section"> | string
    contains?: EnumContentTypeFilter<"Section"> | $Enums.ContentType
    signature?: IntFilter<"Section"> | number
    status?: BoolFilter<"Section"> | boolean
    deletedAt?: DateTimeNullableFilter<"Section"> | Date | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
  }, "id">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    pattern?: SortOrder
    contains?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Section"> | number
    title?: StringWithAggregatesFilter<"Section"> | string
    slug?: StringNullableWithAggregatesFilter<"Section"> | string | null
    subtitle?: StringNullableWithAggregatesFilter<"Section"> | string | null
    pattern?: StringWithAggregatesFilter<"Section"> | string
    contains?: EnumContentTypeWithAggregatesFilter<"Section"> | $Enums.ContentType
    signature?: IntWithAggregatesFilter<"Section"> | number
    status?: BoolWithAggregatesFilter<"Section"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Section"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
  }

  export type EventsWhereInput = {
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    id?: IntFilter<"Events"> | number
    propertyId?: IntFilter<"Events"> | number
    branchId?: IntNullableFilter<"Events"> | number | null
    location?: StringNullableFilter<"Events"> | string | null
    mapLocation?: StringNullableFilter<"Events"> | string | null
    address?: StringNullableFilter<"Events"> | string | null
    capacity?: IntFilter<"Events"> | number
    startDate?: DateTimeFilter<"Events"> | Date | string
    endDate?: DateTimeNullableFilter<"Events"> | Date | string | null
    status?: BoolFilter<"Events"> | boolean
    deletedAt?: DateTimeNullableFilter<"Events"> | Date | string | null
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Events"> | Date | string | null
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    evbooking?: EvbookingListRelationFilter
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    mapLocation?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    capacity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    evbooking?: EvbookingOrderByRelationAggregateInput
    _relevance?: EventsOrderByRelevanceInput
  }

  export type EventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    propertyId?: IntFilter<"Events"> | number
    branchId?: IntNullableFilter<"Events"> | number | null
    location?: StringNullableFilter<"Events"> | string | null
    mapLocation?: StringNullableFilter<"Events"> | string | null
    address?: StringNullableFilter<"Events"> | string | null
    capacity?: IntFilter<"Events"> | number
    startDate?: DateTimeFilter<"Events"> | Date | string
    endDate?: DateTimeNullableFilter<"Events"> | Date | string | null
    status?: BoolFilter<"Events"> | boolean
    deletedAt?: DateTimeNullableFilter<"Events"> | Date | string | null
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Events"> | Date | string | null
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    evbooking?: EvbookingListRelationFilter
  }, "id">

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    mapLocation?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    capacity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EventsCountOrderByAggregateInput
    _avg?: EventsAvgOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
    _sum?: EventsSumOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    OR?: EventsScalarWhereWithAggregatesInput[]
    NOT?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Events"> | number
    propertyId?: IntWithAggregatesFilter<"Events"> | number
    branchId?: IntNullableWithAggregatesFilter<"Events"> | number | null
    location?: StringNullableWithAggregatesFilter<"Events"> | string | null
    mapLocation?: StringNullableWithAggregatesFilter<"Events"> | string | null
    address?: StringNullableWithAggregatesFilter<"Events"> | string | null
    capacity?: IntWithAggregatesFilter<"Events"> | number
    startDate?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Events"> | Date | string | null
    status?: BoolWithAggregatesFilter<"Events"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Events"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Events"> | Date | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    propertyId?: IntNullableFilter<"Booking"> | number | null
    branchId?: IntFilter<"Booking"> | number
    tableId?: IntNullableFilter<"Booking"> | number | null
    seatBedId?: IntNullableFilter<"Booking"> | number | null
    ownerId?: IntNullableFilter<"Booking"> | number | null
    customerId?: IntNullableFilter<"Booking"> | number | null
    customerName?: StringFilter<"Booking"> | string
    phoneNumber?: StringNullableFilter<"Booking"> | string | null
    startDate?: DateTimeFilter<"Booking"> | Date | string
    endDate?: DateTimeFilter<"Booking"> | Date | string
    slot?: StringNullableFilter<"Booking"> | string | null
    comment?: StringNullableFilter<"Booking"> | string | null
    customerRequest?: StringNullableFilter<"Booking"> | string | null
    cancelReason?: StringNullableFilter<"Booking"> | string | null
    guestNumber?: IntNullableFilter<"Booking"> | number | null
    amount?: IntFilter<"Booking"> | number
    vat?: IntFilter<"Booking"> | number
    discount?: IntFilter<"Booking"> | number
    grandTotal?: IntFilter<"Booking"> | number
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    bookingType?: StringNullableFilter<"Booking"> | string | null
    optionalData?: JsonNullableFilter<"Booking">
    deletedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    property?: XOR<PropertyNullableRelationFilter, PropertyWhereInput> | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    table?: XOR<TableNullableRelationFilter, TableWhereInput> | null
    seatBed?: XOR<SeatBedNullableRelationFilter, SeatBedWhereInput> | null
    owner?: XOR<OwnerNullableRelationFilter, OwnerWhereInput> | null
    customer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    payments?: PaymentListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    branchId?: SortOrder
    tableId?: SortOrderInput | SortOrder
    seatBedId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    slot?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    customerRequest?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    guestNumber?: SortOrderInput | SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    bookingType?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    table?: TableOrderByWithRelationInput
    seatBed?: SeatBedOrderByWithRelationInput
    owner?: OwnerOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: BookingOrderByRelevanceInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    propertyId?: IntNullableFilter<"Booking"> | number | null
    branchId?: IntFilter<"Booking"> | number
    tableId?: IntNullableFilter<"Booking"> | number | null
    seatBedId?: IntNullableFilter<"Booking"> | number | null
    ownerId?: IntNullableFilter<"Booking"> | number | null
    customerId?: IntNullableFilter<"Booking"> | number | null
    customerName?: StringFilter<"Booking"> | string
    phoneNumber?: StringNullableFilter<"Booking"> | string | null
    startDate?: DateTimeFilter<"Booking"> | Date | string
    endDate?: DateTimeFilter<"Booking"> | Date | string
    slot?: StringNullableFilter<"Booking"> | string | null
    comment?: StringNullableFilter<"Booking"> | string | null
    customerRequest?: StringNullableFilter<"Booking"> | string | null
    cancelReason?: StringNullableFilter<"Booking"> | string | null
    guestNumber?: IntNullableFilter<"Booking"> | number | null
    amount?: IntFilter<"Booking"> | number
    vat?: IntFilter<"Booking"> | number
    discount?: IntFilter<"Booking"> | number
    grandTotal?: IntFilter<"Booking"> | number
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    bookingType?: StringNullableFilter<"Booking"> | string | null
    optionalData?: JsonNullableFilter<"Booking">
    deletedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    property?: XOR<PropertyNullableRelationFilter, PropertyWhereInput> | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    table?: XOR<TableNullableRelationFilter, TableWhereInput> | null
    seatBed?: XOR<SeatBedNullableRelationFilter, SeatBedWhereInput> | null
    owner?: XOR<OwnerNullableRelationFilter, OwnerWhereInput> | null
    customer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    payments?: PaymentListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    branchId?: SortOrder
    tableId?: SortOrderInput | SortOrder
    seatBedId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    slot?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    customerRequest?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    guestNumber?: SortOrderInput | SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    bookingType?: SortOrderInput | SortOrder
    optionalData?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    propertyId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    branchId?: IntWithAggregatesFilter<"Booking"> | number
    tableId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    seatBedId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    ownerId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    customerId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    customerName?: StringWithAggregatesFilter<"Booking"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    slot?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    customerRequest?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestNumber?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    amount?: IntWithAggregatesFilter<"Booking"> | number
    vat?: IntWithAggregatesFilter<"Booking"> | number
    discount?: IntWithAggregatesFilter<"Booking"> | number
    grandTotal?: IntWithAggregatesFilter<"Booking"> | number
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    bookingType?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    optionalData?: JsonNullableWithAggregatesFilter<"Booking">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntFilter<"Payment"> | number
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentInfo?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentInfo?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: IntFilter<"Payment"> | number
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentInfo?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentInfo?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    bookingId?: IntWithAggregatesFilter<"Payment"> | number
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    paymentInfo?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AmenitiesWhereInput = {
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    id?: IntFilter<"Amenities"> | number
    name?: StringFilter<"Amenities"> | string
    icon?: StringNullableFilter<"Amenities"> | string | null
    price?: FloatFilter<"Amenities"> | number
    status?: BoolFilter<"Amenities"> | boolean
    deletedAt?: DateTimeNullableFilter<"Amenities"> | Date | string | null
    createdAt?: DateTimeFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeFilter<"Amenities"> | Date | string
  }

  export type AmenitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    price?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AmenitiesOrderByRelevanceInput
  }

  export type AmenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    name?: StringFilter<"Amenities"> | string
    icon?: StringNullableFilter<"Amenities"> | string | null
    price?: FloatFilter<"Amenities"> | number
    status?: BoolFilter<"Amenities"> | boolean
    deletedAt?: DateTimeNullableFilter<"Amenities"> | Date | string | null
    createdAt?: DateTimeFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeFilter<"Amenities"> | Date | string
  }, "id">

  export type AmenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    price?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmenitiesCountOrderByAggregateInput
    _avg?: AmenitiesAvgOrderByAggregateInput
    _max?: AmenitiesMaxOrderByAggregateInput
    _min?: AmenitiesMinOrderByAggregateInput
    _sum?: AmenitiesSumOrderByAggregateInput
  }

  export type AmenitiesScalarWhereWithAggregatesInput = {
    AND?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    OR?: AmenitiesScalarWhereWithAggregatesInput[]
    NOT?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Amenities"> | number
    name?: StringWithAggregatesFilter<"Amenities"> | string
    icon?: StringNullableWithAggregatesFilter<"Amenities"> | string | null
    price?: FloatWithAggregatesFilter<"Amenities"> | number
    status?: BoolWithAggregatesFilter<"Amenities"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Amenities"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Amenities"> | Date | string
  }

  export type CuisineWhereInput = {
    AND?: CuisineWhereInput | CuisineWhereInput[]
    OR?: CuisineWhereInput[]
    NOT?: CuisineWhereInput | CuisineWhereInput[]
    id?: IntFilter<"Cuisine"> | number
    name?: StringFilter<"Cuisine"> | string
    status?: BoolFilter<"Cuisine"> | boolean
    deletedAt?: DateTimeNullableFilter<"Cuisine"> | Date | string | null
    createdAt?: DateTimeFilter<"Cuisine"> | Date | string
    updatedAt?: DateTimeFilter<"Cuisine"> | Date | string
  }

  export type CuisineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CuisineOrderByRelevanceInput
  }

  export type CuisineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CuisineWhereInput | CuisineWhereInput[]
    OR?: CuisineWhereInput[]
    NOT?: CuisineWhereInput | CuisineWhereInput[]
    name?: StringFilter<"Cuisine"> | string
    status?: BoolFilter<"Cuisine"> | boolean
    deletedAt?: DateTimeNullableFilter<"Cuisine"> | Date | string | null
    createdAt?: DateTimeFilter<"Cuisine"> | Date | string
    updatedAt?: DateTimeFilter<"Cuisine"> | Date | string
  }, "id">

  export type CuisineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CuisineCountOrderByAggregateInput
    _avg?: CuisineAvgOrderByAggregateInput
    _max?: CuisineMaxOrderByAggregateInput
    _min?: CuisineMinOrderByAggregateInput
    _sum?: CuisineSumOrderByAggregateInput
  }

  export type CuisineScalarWhereWithAggregatesInput = {
    AND?: CuisineScalarWhereWithAggregatesInput | CuisineScalarWhereWithAggregatesInput[]
    OR?: CuisineScalarWhereWithAggregatesInput[]
    NOT?: CuisineScalarWhereWithAggregatesInput | CuisineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cuisine"> | number
    name?: StringWithAggregatesFilter<"Cuisine"> | string
    status?: BoolWithAggregatesFilter<"Cuisine"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Cuisine"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cuisine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cuisine"> | Date | string
  }

  export type EvbookingWhereInput = {
    AND?: EvbookingWhereInput | EvbookingWhereInput[]
    OR?: EvbookingWhereInput[]
    NOT?: EvbookingWhereInput | EvbookingWhereInput[]
    id?: IntFilter<"Evbooking"> | number
    username?: StringFilter<"Evbooking"> | string
    phoneNumber?: StringFilter<"Evbooking"> | string
    email?: StringNullableFilter<"Evbooking"> | string | null
    address?: StringNullableFilter<"Evbooking"> | string | null
    ticketNumber?: StringFilter<"Evbooking"> | string
    person?: IntFilter<"Evbooking"> | number
    price?: IntFilter<"Evbooking"> | number
    amount?: FloatFilter<"Evbooking"> | number
    vat?: FloatFilter<"Evbooking"> | number
    payStatus?: EnumPaymentStatusFilter<"Evbooking"> | $Enums.PaymentStatus
    eventDate?: DateTimeFilter<"Evbooking"> | Date | string
    eventId?: IntFilter<"Evbooking"> | number
    status?: BoolFilter<"Evbooking"> | boolean
    optionalData?: JsonNullableFilter<"Evbooking">
    issueAt?: DateTimeFilter<"Evbooking"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Evbooking"> | Date | string | null
    createdAt?: DateTimeFilter<"Evbooking"> | Date | string
    updatedAt?: DateTimeFilter<"Evbooking"> | Date | string
    event?: XOR<EventsRelationFilter, EventsWhereInput>
  }

  export type EvbookingOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    ticketNumber?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    payStatus?: SortOrder
    eventDate?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    optionalData?: SortOrderInput | SortOrder
    issueAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventsOrderByWithRelationInput
    _relevance?: EvbookingOrderByRelevanceInput
  }

  export type EvbookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvbookingWhereInput | EvbookingWhereInput[]
    OR?: EvbookingWhereInput[]
    NOT?: EvbookingWhereInput | EvbookingWhereInput[]
    username?: StringFilter<"Evbooking"> | string
    phoneNumber?: StringFilter<"Evbooking"> | string
    email?: StringNullableFilter<"Evbooking"> | string | null
    address?: StringNullableFilter<"Evbooking"> | string | null
    ticketNumber?: StringFilter<"Evbooking"> | string
    person?: IntFilter<"Evbooking"> | number
    price?: IntFilter<"Evbooking"> | number
    amount?: FloatFilter<"Evbooking"> | number
    vat?: FloatFilter<"Evbooking"> | number
    payStatus?: EnumPaymentStatusFilter<"Evbooking"> | $Enums.PaymentStatus
    eventDate?: DateTimeFilter<"Evbooking"> | Date | string
    eventId?: IntFilter<"Evbooking"> | number
    status?: BoolFilter<"Evbooking"> | boolean
    optionalData?: JsonNullableFilter<"Evbooking">
    issueAt?: DateTimeFilter<"Evbooking"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Evbooking"> | Date | string | null
    createdAt?: DateTimeFilter<"Evbooking"> | Date | string
    updatedAt?: DateTimeFilter<"Evbooking"> | Date | string
    event?: XOR<EventsRelationFilter, EventsWhereInput>
  }, "id">

  export type EvbookingOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    ticketNumber?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    payStatus?: SortOrder
    eventDate?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    optionalData?: SortOrderInput | SortOrder
    issueAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvbookingCountOrderByAggregateInput
    _avg?: EvbookingAvgOrderByAggregateInput
    _max?: EvbookingMaxOrderByAggregateInput
    _min?: EvbookingMinOrderByAggregateInput
    _sum?: EvbookingSumOrderByAggregateInput
  }

  export type EvbookingScalarWhereWithAggregatesInput = {
    AND?: EvbookingScalarWhereWithAggregatesInput | EvbookingScalarWhereWithAggregatesInput[]
    OR?: EvbookingScalarWhereWithAggregatesInput[]
    NOT?: EvbookingScalarWhereWithAggregatesInput | EvbookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evbooking"> | number
    username?: StringWithAggregatesFilter<"Evbooking"> | string
    phoneNumber?: StringWithAggregatesFilter<"Evbooking"> | string
    email?: StringNullableWithAggregatesFilter<"Evbooking"> | string | null
    address?: StringNullableWithAggregatesFilter<"Evbooking"> | string | null
    ticketNumber?: StringWithAggregatesFilter<"Evbooking"> | string
    person?: IntWithAggregatesFilter<"Evbooking"> | number
    price?: IntWithAggregatesFilter<"Evbooking"> | number
    amount?: FloatWithAggregatesFilter<"Evbooking"> | number
    vat?: FloatWithAggregatesFilter<"Evbooking"> | number
    payStatus?: EnumPaymentStatusWithAggregatesFilter<"Evbooking"> | $Enums.PaymentStatus
    eventDate?: DateTimeWithAggregatesFilter<"Evbooking"> | Date | string
    eventId?: IntWithAggregatesFilter<"Evbooking"> | number
    status?: BoolWithAggregatesFilter<"Evbooking"> | boolean
    optionalData?: JsonNullableWithAggregatesFilter<"Evbooking">
    issueAt?: DateTimeWithAggregatesFilter<"Evbooking"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Evbooking"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evbooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evbooking"> | Date | string
  }

  export type SessionCreateInput = {
    sessionToken: string
    userId?: number | null
    expires: Date | string
    loggerType?: $Enums.loggerType | null
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    sessionToken: string
    userId?: number | null
    expires: Date | string
    loggerType?: $Enums.loggerType | null
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
  }

  export type SessionCreateManyInput = {
    id?: number
    sessionToken: string
    userId?: number | null
    expires: Date | string
    loggerType?: $Enums.loggerType | null
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
  }

  export type OwnerCreateInput = {
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedOneWithoutOwnerInput
    branch?: BranchCreateNestedManyWithoutOwnerInput
    property?: PropertyCreateNestedManyWithoutOwnerInput
    booking?: BookingCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    roleId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutOwnerInput
    property?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    booking?: BookingUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateOneWithoutOwnerNestedInput
    branch?: BranchUpdateManyWithoutOwnerNestedInput
    property?: PropertyUpdateManyWithoutOwnerNestedInput
    booking?: BookingUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutOwnerNestedInput
    property?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    booking?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateManyInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    roleId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userType?: $Enums.UserType | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    picture?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: number | null
    tin?: string | null
    password?: string | null
    otp?: number | null
    otpExpireAt?: Date | string | null
    isVerify?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedManyWithoutCustomerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userType?: $Enums.UserType | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    picture?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: number | null
    tin?: string | null
    password?: string | null
    otp?: number | null
    otpExpireAt?: Date | string | null
    isVerify?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableIntFieldUpdateOperationsInput | number | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateManyWithoutCustomerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableIntFieldUpdateOperationsInput | number | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userType?: $Enums.UserType | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    picture?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: number | null
    tin?: string | null
    password?: string | null
    otp?: number | null
    otpExpireAt?: Date | string | null
    isVerify?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableIntFieldUpdateOperationsInput | number | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableIntFieldUpdateOperationsInput | number | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutRolePermissionInput
    owner?: OwnerCreateNestedManyWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    branchId: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: OwnerUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolePermissionUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutRolePermissionNestedInput
    owner?: OwnerUpdateManyWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    branchId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    branchId: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    branchId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishListCreateInput = {
    type?: $Enums.BusinessCategory | null
    userId?: number | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property?: PropertyCreateNestedOneWithoutWishListsInput
  }

  export type wishListUncheckedCreateInput = {
    id?: number
    type?: $Enums.BusinessCategory | null
    userId?: number | null
    propertyId?: number | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wishListUpdateInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneWithoutWishListsNestedInput
  }

  export type wishListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishListCreateManyInput = {
    id?: number
    type?: $Enums.BusinessCategory | null
    userId?: number | null
    propertyId?: number | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wishListUpdateManyMutationInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutBranchInput
    property: PropertyCreateNestedOneWithoutBranchesInput
    booking?: BookingCreateNestedManyWithoutBranchInput
    events?: EventsCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    ownerId: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutBranchInput
    events?: EventsUncheckedCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutBranchNestedInput
    property?: PropertyUpdateOneRequiredWithoutBranchesNestedInput
    booking?: BookingUpdateManyWithoutBranchNestedInput
    events?: EventsUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    events?: EventsUncheckedUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    ownerId: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateInput = {
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutTablesInput
    booking?: BookingCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: number
    propertyId: number
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutTablesNestedInput
    booking?: BookingUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: number
    propertyId: number
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableUpdateManyMutationInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatBedCreateInput = {
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutSeatBedInput
    booking?: BookingCreateNestedManyWithoutSeatBedInput
  }

  export type SeatBedUncheckedCreateInput = {
    id?: number
    propertyId: number
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutSeatBedInput
  }

  export type SeatBedUpdateInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutSeatBedNestedInput
    booking?: BookingUpdateManyWithoutSeatBedNestedInput
  }

  export type SeatBedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutSeatBedNestedInput
  }

  export type SeatBedCreateManyInput = {
    id?: number
    propertyId: number
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatBedUpdateManyMutationInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatBedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCreateInput = {
    name: string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutFoodInput
  }

  export type FoodUncheckedCreateInput = {
    id?: number
    name: string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    propertyId: number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCreateManyInput = {
    id?: number
    name: string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    propertyId: number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    title: string
    slug?: string | null
    subtitle?: string | null
    pattern: string
    contains: $Enums.ContentType
    signature?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUncheckedCreateInput = {
    id?: number
    title: string
    slug?: string | null
    subtitle?: string | null
    pattern: string
    contains: $Enums.ContentType
    signature?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    pattern?: StringFieldUpdateOperationsInput | string
    contains?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    signature?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    pattern?: StringFieldUpdateOperationsInput | string
    contains?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    signature?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyInput = {
    id?: number
    title: string
    slug?: string | null
    subtitle?: string | null
    pattern: string
    contains: $Enums.ContentType
    signature?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    pattern?: StringFieldUpdateOperationsInput | string
    contains?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    signature?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    pattern?: StringFieldUpdateOperationsInput | string
    contains?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    signature?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateInput = {
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutEventInput
    branch?: BranchCreateNestedOneWithoutEventsInput
    evbooking?: EvbookingCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateInput = {
    id?: number
    propertyId: number
    branchId?: number | null
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    evbooking?: EvbookingUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsUpdateInput = {
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutEventNestedInput
    branch?: BranchUpdateOneWithoutEventsNestedInput
    evbooking?: EvbookingUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evbooking?: EvbookingUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventsCreateManyInput = {
    id?: number
    propertyId: number
    branchId?: number | null
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type EventsUpdateManyMutationInput = {
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    branch: BranchCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    paymentDate?: Date | string | null
    paymentInfo?: string | null
    status: $Enums.PaymentStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    bookingId: number
    paymentDate?: Date | string | null
    paymentInfo?: string | null
    status: $Enums.PaymentStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    bookingId: number
    paymentDate?: Date | string | null
    paymentInfo?: string | null
    status: $Enums.PaymentStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesCreateInput = {
    name: string
    icon?: string | null
    price?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUncheckedCreateInput = {
    id?: number
    name: string
    icon?: string | null
    price?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesCreateManyInput = {
    id?: number
    name: string
    icon?: string | null
    price?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuisineCreateInput = {
    name: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CuisineUncheckedCreateInput = {
    id?: number
    name: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CuisineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuisineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuisineCreateManyInput = {
    id?: number
    name: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CuisineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuisineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvbookingCreateInput = {
    username: string
    phoneNumber: string
    email?: string | null
    address?: string | null
    ticketNumber: string
    person?: number
    price?: number
    amount?: number
    vat?: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date | string
    status?: boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt: Date | string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventsCreateNestedOneWithoutEvbookingInput
  }

  export type EvbookingUncheckedCreateInput = {
    id?: number
    username: string
    phoneNumber: string
    email?: string | null
    address?: string | null
    ticketNumber: string
    person?: number
    price?: number
    amount?: number
    vat?: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date | string
    eventId: number
    status?: boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt: Date | string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvbookingUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventsUpdateOneRequiredWithoutEvbookingNestedInput
  }

  export type EvbookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvbookingCreateManyInput = {
    id?: number
    username: string
    phoneNumber: string
    email?: string | null
    address?: string | null
    ticketNumber: string
    person?: number
    price?: number
    amount?: number
    vat?: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date | string
    eventId: number
    status?: boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt: Date | string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvbookingUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvbookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumloggerTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.loggerType | EnumloggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumloggerTypeNullableFilter<$PrismaModel> | $Enums.loggerType | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    loggerType?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    loggerType?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    loggerType?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumloggerTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loggerType | EnumloggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumloggerTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.loggerType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumloggerTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumloggerTypeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableFilter<$PrismaModel> | $Enums.UserType | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RolePermissionNullableRelationFilter = {
    is?: RolePermissionWhereInput | null
    isNot?: RolePermissionWhereInput | null
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerOrderByRelevanceInput = {
    fields: OwnerOrderByRelevanceFieldEnum | OwnerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OwnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userType?: SortOrder
    ownerId?: SortOrder
    roleId?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
    country?: SortOrder
    city?: SortOrder
    location?: SortOrder
    residenceAddress?: SortOrder
    occupation?: SortOrder
    designation?: SortOrder
    nid?: SortOrder
    tin?: SortOrder
    havingBusiness?: SortOrder
    password?: SortOrder
    loggerType?: SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAtAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnerAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roleId?: SortOrder
  }

  export type OwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userType?: SortOrder
    ownerId?: SortOrder
    roleId?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
    country?: SortOrder
    city?: SortOrder
    location?: SortOrder
    residenceAddress?: SortOrder
    occupation?: SortOrder
    designation?: SortOrder
    nid?: SortOrder
    tin?: SortOrder
    havingBusiness?: SortOrder
    password?: SortOrder
    loggerType?: SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAtAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userType?: SortOrder
    ownerId?: SortOrder
    roleId?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
    country?: SortOrder
    city?: SortOrder
    location?: SortOrder
    residenceAddress?: SortOrder
    occupation?: SortOrder
    designation?: SortOrder
    nid?: SortOrder
    tin?: SortOrder
    havingBusiness?: SortOrder
    password?: SortOrder
    loggerType?: SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAtAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnerSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumUserTypeNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
    picture?: SortOrder
    country?: SortOrder
    city?: SortOrder
    location?: SortOrder
    residenceAddress?: SortOrder
    occupation?: SortOrder
    designation?: SortOrder
    nid?: SortOrder
    tin?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpireAt?: SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    nid?: SortOrder
    otp?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
    picture?: SortOrder
    country?: SortOrder
    city?: SortOrder
    location?: SortOrder
    residenceAddress?: SortOrder
    occupation?: SortOrder
    designation?: SortOrder
    nid?: SortOrder
    tin?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpireAt?: SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
    picture?: SortOrder
    country?: SortOrder
    city?: SortOrder
    location?: SortOrder
    residenceAddress?: SortOrder
    occupation?: SortOrder
    designation?: SortOrder
    nid?: SortOrder
    tin?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpireAt?: SortOrder
    isVerify?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    nid?: SortOrder
    otp?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type OwnerListRelationFilter = {
    every?: OwnerWhereInput
    some?: OwnerWhereInput
    none?: OwnerWhereInput
  }

  export type OwnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolePermissionOrderByRelevanceInput = {
    fields: RolePermissionOrderByRelevanceFieldEnum | RolePermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissions?: SortOrder
    branchId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    branchId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    branchId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type EnumBusinessCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessCategory | EnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessCategoryNullableFilter<$PrismaModel> | $Enums.BusinessCategory | null
  }

  export type PropertyNullableRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type wishListCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wishListAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
  }

  export type wishListMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wishListMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wishListSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
  }

  export type EnumBusinessCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessCategory | EnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.BusinessCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBusinessCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumBusinessCategoryNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type OwnerRelationFilter = {
    is?: OwnerWhereInput
    isNot?: OwnerWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type SeatBedListRelationFilter = {
    every?: SeatBedWhereInput
    some?: SeatBedWhereInput
    none?: SeatBedWhereInput
  }

  export type WishListListRelationFilter = {
    every?: wishListWhereInput
    some?: wishListWhereInput
    none?: wishListWhereInput
  }

  export type FoodListRelationFilter = {
    every?: FoodWhereInput
    some?: FoodWhereInput
    none?: FoodWhereInput
  }

  export type EventsListRelationFilter = {
    every?: EventsWhereInput
    some?: EventsWhereInput
    none?: EventsWhereInput
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatBedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wishListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelevanceInput = {
    fields: PropertyOrderByRelevanceFieldEnum | PropertyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    listingName?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    description?: SortOrder
    terms?: SortOrder
    slot?: SortOrder
    offday?: SortOrder
    cuisines?: SortOrder
    reservationCategory?: SortOrder
    sectSymb?: SortOrder
    priority?: SortOrder
    optionalData?: SortOrder
    eventStatus?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    sectSymb?: SortOrder
    priority?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    listingName?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    terms?: SortOrder
    reservationCategory?: SortOrder
    sectSymb?: SortOrder
    priority?: SortOrder
    eventStatus?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    listingName?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    terms?: SortOrder
    reservationCategory?: SortOrder
    sectSymb?: SortOrder
    priority?: SortOrder
    eventStatus?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    sectSymb?: SortOrder
    priority?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type PropertyRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchOrderByRelevanceInput = {
    fields: BranchOrderByRelevanceFieldEnum | BranchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    branchName?: SortOrder
    slug?: SortOrder
    images?: SortOrder
    description?: SortOrder
    level?: SortOrder
    terms?: SortOrder
    city?: SortOrder
    area?: SortOrder
    country?: SortOrder
    amenities?: SortOrder
    amenity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    optionalData?: SortOrder
    bookingCount?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    bookingCount?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    branchName?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    level?: SortOrder
    terms?: SortOrder
    city?: SortOrder
    area?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    bookingCount?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    branchName?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    level?: SortOrder
    terms?: SortOrder
    city?: SortOrder
    area?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    bookingCount?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyId?: SortOrder
    bookingCount?: SortOrder
  }

  export type EnumcompTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.compType | EnumcompTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompTypeNullableFilter<$PrismaModel> | $Enums.compType | null
  }

  export type TableOrderByRelevanceInput = {
    fields: TableOrderByRelevanceFieldEnum | TableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    position?: SortOrder
    size?: SortOrder
    image?: SortOrder
    splitable?: SortOrder
    ryservable?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    capacity?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    position?: SortOrder
    size?: SortOrder
    image?: SortOrder
    splitable?: SortOrder
    ryservable?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    position?: SortOrder
    size?: SortOrder
    image?: SortOrder
    splitable?: SortOrder
    ryservable?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    capacity?: SortOrder
  }

  export type EnumcompTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.compType | EnumcompTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.compType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcompTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumcompTypeNullableFilter<$PrismaModel>
  }

  export type SeatBedOrderByRelevanceInput = {
    fields: SeatBedOrderByRelevanceFieldEnum | SeatBedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeatBedCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    roomNo?: SortOrder
    breakfast?: SortOrder
    image?: SortOrder
    accomodationCapacity?: SortOrder
    extraBedPolicy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatBedAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
  }

  export type SeatBedMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    roomNo?: SortOrder
    breakfast?: SortOrder
    image?: SortOrder
    accomodationCapacity?: SortOrder
    extraBedPolicy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatBedMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    roomNo?: SortOrder
    breakfast?: SortOrder
    image?: SortOrder
    accomodationCapacity?: SortOrder
    extraBedPolicy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatBedSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FoodOrderByRelevanceInput = {
    fields: FoodOrderByRelevanceFieldEnum | FoodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    images?: SortOrder
    optionalData?: SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
  }

  export type FoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    propertyId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type SectionOrderByRelevanceInput = {
    fields: SectionOrderByRelevanceFieldEnum | SectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    subtitle?: SortOrder
    pattern?: SortOrder
    contains?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    id?: SortOrder
    signature?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    subtitle?: SortOrder
    pattern?: SortOrder
    contains?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    subtitle?: SortOrder
    pattern?: SortOrder
    contains?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    id?: SortOrder
    signature?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type EvbookingListRelationFilter = {
    every?: EvbookingWhereInput
    some?: EvbookingWhereInput
    none?: EvbookingWhereInput
  }

  export type EvbookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsOrderByRelevanceInput = {
    fields: EventsOrderByRelevanceFieldEnum | EventsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    location?: SortOrder
    mapLocation?: SortOrder
    address?: SortOrder
    capacity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    capacity?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    location?: SortOrder
    mapLocation?: SortOrder
    address?: SortOrder
    capacity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    location?: SortOrder
    mapLocation?: SortOrder
    address?: SortOrder
    capacity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    capacity?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type TableNullableRelationFilter = {
    is?: TableWhereInput | null
    isNot?: TableWhereInput | null
  }

  export type SeatBedNullableRelationFilter = {
    is?: SeatBedWhereInput | null
    isNot?: SeatBedWhereInput | null
  }

  export type OwnerNullableRelationFilter = {
    is?: OwnerWhereInput | null
    isNot?: OwnerWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelevanceInput = {
    fields: BookingOrderByRelevanceFieldEnum | BookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    tableId?: SortOrder
    seatBedId?: SortOrder
    ownerId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    phoneNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    slot?: SortOrder
    comment?: SortOrder
    customerRequest?: SortOrder
    cancelReason?: SortOrder
    guestNumber?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    bookingType?: SortOrder
    optionalData?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    tableId?: SortOrder
    seatBedId?: SortOrder
    ownerId?: SortOrder
    customerId?: SortOrder
    guestNumber?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    tableId?: SortOrder
    seatBedId?: SortOrder
    ownerId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    phoneNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    slot?: SortOrder
    comment?: SortOrder
    customerRequest?: SortOrder
    cancelReason?: SortOrder
    guestNumber?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    bookingType?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    tableId?: SortOrder
    seatBedId?: SortOrder
    ownerId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    phoneNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    slot?: SortOrder
    comment?: SortOrder
    customerRequest?: SortOrder
    cancelReason?: SortOrder
    guestNumber?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
    status?: SortOrder
    bookingType?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    branchId?: SortOrder
    tableId?: SortOrder
    seatBedId?: SortOrder
    ownerId?: SortOrder
    customerId?: SortOrder
    guestNumber?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    discount?: SortOrder
    grandTotal?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentDate?: SortOrder
    paymentInfo?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentDate?: SortOrder
    paymentInfo?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentDate?: SortOrder
    paymentInfo?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type AmenitiesOrderByRelevanceInput = {
    fields: AmenitiesOrderByRelevanceFieldEnum | AmenitiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    price?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitiesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type AmenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    price?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    price?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitiesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type CuisineOrderByRelevanceInput = {
    fields: CuisineOrderByRelevanceFieldEnum | CuisineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CuisineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CuisineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CuisineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CuisineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CuisineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventsRelationFilter = {
    is?: EventsWhereInput
    isNot?: EventsWhereInput
  }

  export type EvbookingOrderByRelevanceInput = {
    fields: EvbookingOrderByRelevanceFieldEnum | EvbookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EvbookingCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    address?: SortOrder
    ticketNumber?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    payStatus?: SortOrder
    eventDate?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    optionalData?: SortOrder
    issueAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvbookingAvgOrderByAggregateInput = {
    id?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    eventId?: SortOrder
  }

  export type EvbookingMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    address?: SortOrder
    ticketNumber?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    payStatus?: SortOrder
    eventDate?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    issueAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvbookingMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    address?: SortOrder
    ticketNumber?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    payStatus?: SortOrder
    eventDate?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    issueAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvbookingSumOrderByAggregateInput = {
    id?: SortOrder
    person?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    vat?: SortOrder
    eventId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumloggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.loggerType | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolePermissionCreateNestedOneWithoutOwnerInput = {
    create?: XOR<RolePermissionCreateWithoutOwnerInput, RolePermissionUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: RolePermissionCreateOrConnectWithoutOwnerInput
    connect?: RolePermissionWhereUniqueInput
  }

  export type BranchCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BranchCreateWithoutOwnerInput, BranchUncheckedCreateWithoutOwnerInput> | BranchCreateWithoutOwnerInput[] | BranchUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutOwnerInput | BranchCreateOrConnectWithoutOwnerInput[]
    createMany?: BranchCreateManyOwnerInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BranchCreateWithoutOwnerInput, BranchUncheckedCreateWithoutOwnerInput> | BranchCreateWithoutOwnerInput[] | BranchUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutOwnerInput | BranchCreateOrConnectWithoutOwnerInput[]
    createMany?: BranchCreateManyOwnerInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RolePermissionUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<RolePermissionCreateWithoutOwnerInput, RolePermissionUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: RolePermissionCreateOrConnectWithoutOwnerInput
    upsert?: RolePermissionUpsertWithoutOwnerInput
    disconnect?: RolePermissionWhereInput | boolean
    delete?: RolePermissionWhereInput | boolean
    connect?: RolePermissionWhereUniqueInput
    update?: XOR<XOR<RolePermissionUpdateToOneWithWhereWithoutOwnerInput, RolePermissionUpdateWithoutOwnerInput>, RolePermissionUncheckedUpdateWithoutOwnerInput>
  }

  export type BranchUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BranchCreateWithoutOwnerInput, BranchUncheckedCreateWithoutOwnerInput> | BranchCreateWithoutOwnerInput[] | BranchUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutOwnerInput | BranchCreateOrConnectWithoutOwnerInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutOwnerInput | BranchUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BranchCreateManyOwnerInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutOwnerInput | BranchUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutOwnerInput | BranchUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOwnerInput | BookingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOwnerInput | BookingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOwnerInput | BookingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BranchCreateWithoutOwnerInput, BranchUncheckedCreateWithoutOwnerInput> | BranchCreateWithoutOwnerInput[] | BranchUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutOwnerInput | BranchCreateOrConnectWithoutOwnerInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutOwnerInput | BranchUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BranchCreateManyOwnerInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutOwnerInput | BranchUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutOwnerInput | BranchUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOwnerInput | BookingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOwnerInput | BookingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOwnerInput | BookingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type RolePermissionCreatepermissionsInput = {
    set: string[]
  }

  export type BranchCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<BranchCreateWithoutRolePermissionInput, BranchUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutRolePermissionInput
    connect?: BranchWhereUniqueInput
  }

  export type OwnerCreateNestedManyWithoutRolesInput = {
    create?: XOR<OwnerCreateWithoutRolesInput, OwnerUncheckedCreateWithoutRolesInput> | OwnerCreateWithoutRolesInput[] | OwnerUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutRolesInput | OwnerCreateOrConnectWithoutRolesInput[]
    createMany?: OwnerCreateManyRolesInputEnvelope
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
  }

  export type OwnerUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<OwnerCreateWithoutRolesInput, OwnerUncheckedCreateWithoutRolesInput> | OwnerCreateWithoutRolesInput[] | OwnerUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutRolesInput | OwnerCreateOrConnectWithoutRolesInput[]
    createMany?: OwnerCreateManyRolesInputEnvelope
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
  }

  export type RolePermissionUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BranchUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<BranchCreateWithoutRolePermissionInput, BranchUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutRolePermissionInput
    upsert?: BranchUpsertWithoutRolePermissionInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutRolePermissionInput, BranchUpdateWithoutRolePermissionInput>, BranchUncheckedUpdateWithoutRolePermissionInput>
  }

  export type OwnerUpdateManyWithoutRolesNestedInput = {
    create?: XOR<OwnerCreateWithoutRolesInput, OwnerUncheckedCreateWithoutRolesInput> | OwnerCreateWithoutRolesInput[] | OwnerUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutRolesInput | OwnerCreateOrConnectWithoutRolesInput[]
    upsert?: OwnerUpsertWithWhereUniqueWithoutRolesInput | OwnerUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: OwnerCreateManyRolesInputEnvelope
    set?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    disconnect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    delete?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    update?: OwnerUpdateWithWhereUniqueWithoutRolesInput | OwnerUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: OwnerUpdateManyWithWhereWithoutRolesInput | OwnerUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
  }

  export type OwnerUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<OwnerCreateWithoutRolesInput, OwnerUncheckedCreateWithoutRolesInput> | OwnerCreateWithoutRolesInput[] | OwnerUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutRolesInput | OwnerCreateOrConnectWithoutRolesInput[]
    upsert?: OwnerUpsertWithWhereUniqueWithoutRolesInput | OwnerUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: OwnerCreateManyRolesInputEnvelope
    set?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    disconnect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    delete?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    update?: OwnerUpdateWithWhereUniqueWithoutRolesInput | OwnerUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: OwnerUpdateManyWithWhereWithoutRolesInput | OwnerUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutWishListsInput = {
    create?: XOR<PropertyCreateWithoutWishListsInput, PropertyUncheckedCreateWithoutWishListsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutWishListsInput
    connect?: PropertyWhereUniqueInput
  }

  export type NullableEnumBusinessCategoryFieldUpdateOperationsInput = {
    set?: $Enums.BusinessCategory | null
  }

  export type PropertyUpdateOneWithoutWishListsNestedInput = {
    create?: XOR<PropertyCreateWithoutWishListsInput, PropertyUncheckedCreateWithoutWishListsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutWishListsInput
    upsert?: PropertyUpsertWithoutWishListsInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutWishListsInput, PropertyUpdateWithoutWishListsInput>, PropertyUncheckedUpdateWithoutWishListsInput>
  }

  export type PropertyCreatecuisinesInput = {
    set: string[]
  }

  export type OwnerCreateNestedOneWithoutPropertyInput = {
    create?: XOR<OwnerCreateWithoutPropertyInput, OwnerUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutPropertyInput
    connect?: OwnerWhereUniqueInput
  }

  export type TableCreateNestedManyWithoutPropertyInput = {
    create?: XOR<TableCreateWithoutPropertyInput, TableUncheckedCreateWithoutPropertyInput> | TableCreateWithoutPropertyInput[] | TableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPropertyInput | TableCreateOrConnectWithoutPropertyInput[]
    createMany?: TableCreateManyPropertyInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type SeatBedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SeatBedCreateWithoutPropertyInput, SeatBedUncheckedCreateWithoutPropertyInput> | SeatBedCreateWithoutPropertyInput[] | SeatBedUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SeatBedCreateOrConnectWithoutPropertyInput | SeatBedCreateOrConnectWithoutPropertyInput[]
    createMany?: SeatBedCreateManyPropertyInputEnvelope
    connect?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type wishListCreateNestedManyWithoutPropertyInput = {
    create?: XOR<wishListCreateWithoutPropertyInput, wishListUncheckedCreateWithoutPropertyInput> | wishListCreateWithoutPropertyInput[] | wishListUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: wishListCreateOrConnectWithoutPropertyInput | wishListCreateOrConnectWithoutPropertyInput[]
    createMany?: wishListCreateManyPropertyInputEnvelope
    connect?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
  }

  export type FoodCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FoodCreateWithoutPropertyInput, FoodUncheckedCreateWithoutPropertyInput> | FoodCreateWithoutPropertyInput[] | FoodUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutPropertyInput | FoodCreateOrConnectWithoutPropertyInput[]
    createMany?: FoodCreateManyPropertyInputEnvelope
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
  }

  export type BranchCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BranchCreateWithoutPropertyInput, BranchUncheckedCreateWithoutPropertyInput> | BranchCreateWithoutPropertyInput[] | BranchUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPropertyInput | BranchCreateOrConnectWithoutPropertyInput[]
    createMany?: BranchCreateManyPropertyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type EventsCreateNestedManyWithoutPropertyInput = {
    create?: XOR<EventsCreateWithoutPropertyInput, EventsUncheckedCreateWithoutPropertyInput> | EventsCreateWithoutPropertyInput[] | EventsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutPropertyInput | EventsCreateOrConnectWithoutPropertyInput[]
    createMany?: EventsCreateManyPropertyInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<TableCreateWithoutPropertyInput, TableUncheckedCreateWithoutPropertyInput> | TableCreateWithoutPropertyInput[] | TableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPropertyInput | TableCreateOrConnectWithoutPropertyInput[]
    createMany?: TableCreateManyPropertyInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type SeatBedUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SeatBedCreateWithoutPropertyInput, SeatBedUncheckedCreateWithoutPropertyInput> | SeatBedCreateWithoutPropertyInput[] | SeatBedUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SeatBedCreateOrConnectWithoutPropertyInput | SeatBedCreateOrConnectWithoutPropertyInput[]
    createMany?: SeatBedCreateManyPropertyInputEnvelope
    connect?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type wishListUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<wishListCreateWithoutPropertyInput, wishListUncheckedCreateWithoutPropertyInput> | wishListCreateWithoutPropertyInput[] | wishListUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: wishListCreateOrConnectWithoutPropertyInput | wishListCreateOrConnectWithoutPropertyInput[]
    createMany?: wishListCreateManyPropertyInputEnvelope
    connect?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
  }

  export type FoodUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FoodCreateWithoutPropertyInput, FoodUncheckedCreateWithoutPropertyInput> | FoodCreateWithoutPropertyInput[] | FoodUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutPropertyInput | FoodCreateOrConnectWithoutPropertyInput[]
    createMany?: FoodCreateManyPropertyInputEnvelope
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BranchCreateWithoutPropertyInput, BranchUncheckedCreateWithoutPropertyInput> | BranchCreateWithoutPropertyInput[] | BranchUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPropertyInput | BranchCreateOrConnectWithoutPropertyInput[]
    createMany?: BranchCreateManyPropertyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<EventsCreateWithoutPropertyInput, EventsUncheckedCreateWithoutPropertyInput> | EventsCreateWithoutPropertyInput[] | EventsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutPropertyInput | EventsCreateOrConnectWithoutPropertyInput[]
    createMany?: EventsCreateManyPropertyInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type PropertyUpdatecuisinesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
  }

  export type OwnerUpdateOneRequiredWithoutPropertyNestedInput = {
    create?: XOR<OwnerCreateWithoutPropertyInput, OwnerUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutPropertyInput
    upsert?: OwnerUpsertWithoutPropertyInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutPropertyInput, OwnerUpdateWithoutPropertyInput>, OwnerUncheckedUpdateWithoutPropertyInput>
  }

  export type TableUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<TableCreateWithoutPropertyInput, TableUncheckedCreateWithoutPropertyInput> | TableCreateWithoutPropertyInput[] | TableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPropertyInput | TableCreateOrConnectWithoutPropertyInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutPropertyInput | TableUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: TableCreateManyPropertyInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutPropertyInput | TableUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: TableUpdateManyWithWhereWithoutPropertyInput | TableUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type SeatBedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SeatBedCreateWithoutPropertyInput, SeatBedUncheckedCreateWithoutPropertyInput> | SeatBedCreateWithoutPropertyInput[] | SeatBedUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SeatBedCreateOrConnectWithoutPropertyInput | SeatBedCreateOrConnectWithoutPropertyInput[]
    upsert?: SeatBedUpsertWithWhereUniqueWithoutPropertyInput | SeatBedUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SeatBedCreateManyPropertyInputEnvelope
    set?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    disconnect?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    delete?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    connect?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    update?: SeatBedUpdateWithWhereUniqueWithoutPropertyInput | SeatBedUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SeatBedUpdateManyWithWhereWithoutPropertyInput | SeatBedUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SeatBedScalarWhereInput | SeatBedScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPropertyInput | BookingUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPropertyInput | BookingUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPropertyInput | BookingUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type wishListUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<wishListCreateWithoutPropertyInput, wishListUncheckedCreateWithoutPropertyInput> | wishListCreateWithoutPropertyInput[] | wishListUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: wishListCreateOrConnectWithoutPropertyInput | wishListCreateOrConnectWithoutPropertyInput[]
    upsert?: wishListUpsertWithWhereUniqueWithoutPropertyInput | wishListUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: wishListCreateManyPropertyInputEnvelope
    set?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    disconnect?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    delete?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    connect?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    update?: wishListUpdateWithWhereUniqueWithoutPropertyInput | wishListUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: wishListUpdateManyWithWhereWithoutPropertyInput | wishListUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: wishListScalarWhereInput | wishListScalarWhereInput[]
  }

  export type FoodUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FoodCreateWithoutPropertyInput, FoodUncheckedCreateWithoutPropertyInput> | FoodCreateWithoutPropertyInput[] | FoodUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutPropertyInput | FoodCreateOrConnectWithoutPropertyInput[]
    upsert?: FoodUpsertWithWhereUniqueWithoutPropertyInput | FoodUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FoodCreateManyPropertyInputEnvelope
    set?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    disconnect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    delete?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    update?: FoodUpdateWithWhereUniqueWithoutPropertyInput | FoodUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FoodUpdateManyWithWhereWithoutPropertyInput | FoodUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FoodScalarWhereInput | FoodScalarWhereInput[]
  }

  export type BranchUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BranchCreateWithoutPropertyInput, BranchUncheckedCreateWithoutPropertyInput> | BranchCreateWithoutPropertyInput[] | BranchUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPropertyInput | BranchCreateOrConnectWithoutPropertyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutPropertyInput | BranchUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BranchCreateManyPropertyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutPropertyInput | BranchUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutPropertyInput | BranchUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type EventsUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<EventsCreateWithoutPropertyInput, EventsUncheckedCreateWithoutPropertyInput> | EventsCreateWithoutPropertyInput[] | EventsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutPropertyInput | EventsCreateOrConnectWithoutPropertyInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutPropertyInput | EventsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: EventsCreateManyPropertyInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutPropertyInput | EventsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutPropertyInput | EventsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<TableCreateWithoutPropertyInput, TableUncheckedCreateWithoutPropertyInput> | TableCreateWithoutPropertyInput[] | TableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPropertyInput | TableCreateOrConnectWithoutPropertyInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutPropertyInput | TableUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: TableCreateManyPropertyInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutPropertyInput | TableUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: TableUpdateManyWithWhereWithoutPropertyInput | TableUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type SeatBedUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SeatBedCreateWithoutPropertyInput, SeatBedUncheckedCreateWithoutPropertyInput> | SeatBedCreateWithoutPropertyInput[] | SeatBedUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SeatBedCreateOrConnectWithoutPropertyInput | SeatBedCreateOrConnectWithoutPropertyInput[]
    upsert?: SeatBedUpsertWithWhereUniqueWithoutPropertyInput | SeatBedUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SeatBedCreateManyPropertyInputEnvelope
    set?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    disconnect?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    delete?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    connect?: SeatBedWhereUniqueInput | SeatBedWhereUniqueInput[]
    update?: SeatBedUpdateWithWhereUniqueWithoutPropertyInput | SeatBedUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SeatBedUpdateManyWithWhereWithoutPropertyInput | SeatBedUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SeatBedScalarWhereInput | SeatBedScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPropertyInput | BookingUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPropertyInput | BookingUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPropertyInput | BookingUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type wishListUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<wishListCreateWithoutPropertyInput, wishListUncheckedCreateWithoutPropertyInput> | wishListCreateWithoutPropertyInput[] | wishListUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: wishListCreateOrConnectWithoutPropertyInput | wishListCreateOrConnectWithoutPropertyInput[]
    upsert?: wishListUpsertWithWhereUniqueWithoutPropertyInput | wishListUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: wishListCreateManyPropertyInputEnvelope
    set?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    disconnect?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    delete?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    connect?: wishListWhereUniqueInput | wishListWhereUniqueInput[]
    update?: wishListUpdateWithWhereUniqueWithoutPropertyInput | wishListUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: wishListUpdateManyWithWhereWithoutPropertyInput | wishListUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: wishListScalarWhereInput | wishListScalarWhereInput[]
  }

  export type FoodUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FoodCreateWithoutPropertyInput, FoodUncheckedCreateWithoutPropertyInput> | FoodCreateWithoutPropertyInput[] | FoodUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutPropertyInput | FoodCreateOrConnectWithoutPropertyInput[]
    upsert?: FoodUpsertWithWhereUniqueWithoutPropertyInput | FoodUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FoodCreateManyPropertyInputEnvelope
    set?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    disconnect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    delete?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    update?: FoodUpdateWithWhereUniqueWithoutPropertyInput | FoodUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FoodUpdateManyWithWhereWithoutPropertyInput | FoodUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FoodScalarWhereInput | FoodScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BranchCreateWithoutPropertyInput, BranchUncheckedCreateWithoutPropertyInput> | BranchCreateWithoutPropertyInput[] | BranchUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutPropertyInput | BranchCreateOrConnectWithoutPropertyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutPropertyInput | BranchUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BranchCreateManyPropertyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutPropertyInput | BranchUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutPropertyInput | BranchUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<EventsCreateWithoutPropertyInput, EventsUncheckedCreateWithoutPropertyInput> | EventsCreateWithoutPropertyInput[] | EventsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutPropertyInput | EventsCreateOrConnectWithoutPropertyInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutPropertyInput | EventsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: EventsCreateManyPropertyInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutPropertyInput | EventsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutPropertyInput | EventsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type BranchCreateamenityInput = {
    set: string[]
  }

  export type OwnerCreateNestedOneWithoutBranchInput = {
    create?: XOR<OwnerCreateWithoutBranchInput, OwnerUncheckedCreateWithoutBranchInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBranchInput
    connect?: OwnerWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutBranchesInput = {
    create?: XOR<PropertyCreateWithoutBranchesInput, PropertyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBranchesInput
    connect?: PropertyWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EventsCreateNestedManyWithoutBranchInput = {
    create?: XOR<EventsCreateWithoutBranchInput, EventsUncheckedCreateWithoutBranchInput> | EventsCreateWithoutBranchInput[] | EventsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutBranchInput | EventsCreateOrConnectWithoutBranchInput[]
    createMany?: EventsCreateManyBranchInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutBranchInput = {
    create?: XOR<RolePermissionCreateWithoutBranchInput, RolePermissionUncheckedCreateWithoutBranchInput> | RolePermissionCreateWithoutBranchInput[] | RolePermissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutBranchInput | RolePermissionCreateOrConnectWithoutBranchInput[]
    createMany?: RolePermissionCreateManyBranchInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EventsCreateWithoutBranchInput, EventsUncheckedCreateWithoutBranchInput> | EventsCreateWithoutBranchInput[] | EventsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutBranchInput | EventsCreateOrConnectWithoutBranchInput[]
    createMany?: EventsCreateManyBranchInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<RolePermissionCreateWithoutBranchInput, RolePermissionUncheckedCreateWithoutBranchInput> | RolePermissionCreateWithoutBranchInput[] | RolePermissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutBranchInput | RolePermissionCreateOrConnectWithoutBranchInput[]
    createMany?: RolePermissionCreateManyBranchInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type BranchUpdateamenityInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OwnerUpdateOneRequiredWithoutBranchNestedInput = {
    create?: XOR<OwnerCreateWithoutBranchInput, OwnerUncheckedCreateWithoutBranchInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBranchInput
    upsert?: OwnerUpsertWithoutBranchInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutBranchInput, OwnerUpdateWithoutBranchInput>, OwnerUncheckedUpdateWithoutBranchInput>
  }

  export type PropertyUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<PropertyCreateWithoutBranchesInput, PropertyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBranchesInput
    upsert?: PropertyUpsertWithoutBranchesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutBranchesInput, PropertyUpdateWithoutBranchesInput>, PropertyUncheckedUpdateWithoutBranchesInput>
  }

  export type BookingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBranchInput | BookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBranchInput | BookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBranchInput | BookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EventsUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EventsCreateWithoutBranchInput, EventsUncheckedCreateWithoutBranchInput> | EventsCreateWithoutBranchInput[] | EventsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutBranchInput | EventsCreateOrConnectWithoutBranchInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutBranchInput | EventsUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EventsCreateManyBranchInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutBranchInput | EventsUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutBranchInput | EventsUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<RolePermissionCreateWithoutBranchInput, RolePermissionUncheckedCreateWithoutBranchInput> | RolePermissionCreateWithoutBranchInput[] | RolePermissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutBranchInput | RolePermissionCreateOrConnectWithoutBranchInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutBranchInput | RolePermissionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: RolePermissionCreateManyBranchInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutBranchInput | RolePermissionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutBranchInput | RolePermissionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBranchInput | BookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBranchInput | BookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBranchInput | BookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EventsCreateWithoutBranchInput, EventsUncheckedCreateWithoutBranchInput> | EventsCreateWithoutBranchInput[] | EventsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutBranchInput | EventsCreateOrConnectWithoutBranchInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutBranchInput | EventsUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EventsCreateManyBranchInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutBranchInput | EventsUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutBranchInput | EventsUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<RolePermissionCreateWithoutBranchInput, RolePermissionUncheckedCreateWithoutBranchInput> | RolePermissionCreateWithoutBranchInput[] | RolePermissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutBranchInput | RolePermissionCreateOrConnectWithoutBranchInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutBranchInput | RolePermissionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: RolePermissionCreateManyBranchInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutBranchInput | RolePermissionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutBranchInput | RolePermissionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutTablesInput = {
    create?: XOR<PropertyCreateWithoutTablesInput, PropertyUncheckedCreateWithoutTablesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTablesInput
    connect?: PropertyWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutTableInput = {
    create?: XOR<BookingCreateWithoutTableInput, BookingUncheckedCreateWithoutTableInput> | BookingCreateWithoutTableInput[] | BookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTableInput | BookingCreateOrConnectWithoutTableInput[]
    createMany?: BookingCreateManyTableInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<BookingCreateWithoutTableInput, BookingUncheckedCreateWithoutTableInput> | BookingCreateWithoutTableInput[] | BookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTableInput | BookingCreateOrConnectWithoutTableInput[]
    createMany?: BookingCreateManyTableInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NullableEnumcompTypeFieldUpdateOperationsInput = {
    set?: $Enums.compType | null
  }

  export type PropertyUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<PropertyCreateWithoutTablesInput, PropertyUncheckedCreateWithoutTablesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTablesInput
    upsert?: PropertyUpsertWithoutTablesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutTablesInput, PropertyUpdateWithoutTablesInput>, PropertyUncheckedUpdateWithoutTablesInput>
  }

  export type BookingUpdateManyWithoutTableNestedInput = {
    create?: XOR<BookingCreateWithoutTableInput, BookingUncheckedCreateWithoutTableInput> | BookingCreateWithoutTableInput[] | BookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTableInput | BookingCreateOrConnectWithoutTableInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTableInput | BookingUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: BookingCreateManyTableInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTableInput | BookingUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTableInput | BookingUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<BookingCreateWithoutTableInput, BookingUncheckedCreateWithoutTableInput> | BookingCreateWithoutTableInput[] | BookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTableInput | BookingCreateOrConnectWithoutTableInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTableInput | BookingUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: BookingCreateManyTableInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTableInput | BookingUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTableInput | BookingUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutSeatBedInput = {
    create?: XOR<PropertyCreateWithoutSeatBedInput, PropertyUncheckedCreateWithoutSeatBedInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSeatBedInput
    connect?: PropertyWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutSeatBedInput = {
    create?: XOR<BookingCreateWithoutSeatBedInput, BookingUncheckedCreateWithoutSeatBedInput> | BookingCreateWithoutSeatBedInput[] | BookingUncheckedCreateWithoutSeatBedInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSeatBedInput | BookingCreateOrConnectWithoutSeatBedInput[]
    createMany?: BookingCreateManySeatBedInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutSeatBedInput = {
    create?: XOR<BookingCreateWithoutSeatBedInput, BookingUncheckedCreateWithoutSeatBedInput> | BookingCreateWithoutSeatBedInput[] | BookingUncheckedCreateWithoutSeatBedInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSeatBedInput | BookingCreateOrConnectWithoutSeatBedInput[]
    createMany?: BookingCreateManySeatBedInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutSeatBedNestedInput = {
    create?: XOR<PropertyCreateWithoutSeatBedInput, PropertyUncheckedCreateWithoutSeatBedInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSeatBedInput
    upsert?: PropertyUpsertWithoutSeatBedInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutSeatBedInput, PropertyUpdateWithoutSeatBedInput>, PropertyUncheckedUpdateWithoutSeatBedInput>
  }

  export type BookingUpdateManyWithoutSeatBedNestedInput = {
    create?: XOR<BookingCreateWithoutSeatBedInput, BookingUncheckedCreateWithoutSeatBedInput> | BookingCreateWithoutSeatBedInput[] | BookingUncheckedCreateWithoutSeatBedInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSeatBedInput | BookingCreateOrConnectWithoutSeatBedInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutSeatBedInput | BookingUpsertWithWhereUniqueWithoutSeatBedInput[]
    createMany?: BookingCreateManySeatBedInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutSeatBedInput | BookingUpdateWithWhereUniqueWithoutSeatBedInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutSeatBedInput | BookingUpdateManyWithWhereWithoutSeatBedInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutSeatBedNestedInput = {
    create?: XOR<BookingCreateWithoutSeatBedInput, BookingUncheckedCreateWithoutSeatBedInput> | BookingCreateWithoutSeatBedInput[] | BookingUncheckedCreateWithoutSeatBedInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSeatBedInput | BookingCreateOrConnectWithoutSeatBedInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutSeatBedInput | BookingUpsertWithWhereUniqueWithoutSeatBedInput[]
    createMany?: BookingCreateManySeatBedInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutSeatBedInput | BookingUpdateWithWhereUniqueWithoutSeatBedInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutSeatBedInput | BookingUpdateManyWithWhereWithoutSeatBedInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutFoodInput = {
    create?: XOR<PropertyCreateWithoutFoodInput, PropertyUncheckedCreateWithoutFoodInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFoodInput
    connect?: PropertyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyUpdateOneRequiredWithoutFoodNestedInput = {
    create?: XOR<PropertyCreateWithoutFoodInput, PropertyUncheckedCreateWithoutFoodInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFoodInput
    upsert?: PropertyUpsertWithoutFoodInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutFoodInput, PropertyUpdateWithoutFoodInput>, PropertyUncheckedUpdateWithoutFoodInput>
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type PropertyCreateNestedOneWithoutEventInput = {
    create?: XOR<PropertyCreateWithoutEventInput, PropertyUncheckedCreateWithoutEventInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutEventInput
    connect?: PropertyWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutEventsInput = {
    create?: XOR<BranchCreateWithoutEventsInput, BranchUncheckedCreateWithoutEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEventsInput
    connect?: BranchWhereUniqueInput
  }

  export type EvbookingCreateNestedManyWithoutEventInput = {
    create?: XOR<EvbookingCreateWithoutEventInput, EvbookingUncheckedCreateWithoutEventInput> | EvbookingCreateWithoutEventInput[] | EvbookingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EvbookingCreateOrConnectWithoutEventInput | EvbookingCreateOrConnectWithoutEventInput[]
    createMany?: EvbookingCreateManyEventInputEnvelope
    connect?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
  }

  export type EvbookingUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EvbookingCreateWithoutEventInput, EvbookingUncheckedCreateWithoutEventInput> | EvbookingCreateWithoutEventInput[] | EvbookingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EvbookingCreateOrConnectWithoutEventInput | EvbookingCreateOrConnectWithoutEventInput[]
    createMany?: EvbookingCreateManyEventInputEnvelope
    connect?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutEventNestedInput = {
    create?: XOR<PropertyCreateWithoutEventInput, PropertyUncheckedCreateWithoutEventInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutEventInput
    upsert?: PropertyUpsertWithoutEventInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutEventInput, PropertyUpdateWithoutEventInput>, PropertyUncheckedUpdateWithoutEventInput>
  }

  export type BranchUpdateOneWithoutEventsNestedInput = {
    create?: XOR<BranchCreateWithoutEventsInput, BranchUncheckedCreateWithoutEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEventsInput
    upsert?: BranchUpsertWithoutEventsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEventsInput, BranchUpdateWithoutEventsInput>, BranchUncheckedUpdateWithoutEventsInput>
  }

  export type EvbookingUpdateManyWithoutEventNestedInput = {
    create?: XOR<EvbookingCreateWithoutEventInput, EvbookingUncheckedCreateWithoutEventInput> | EvbookingCreateWithoutEventInput[] | EvbookingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EvbookingCreateOrConnectWithoutEventInput | EvbookingCreateOrConnectWithoutEventInput[]
    upsert?: EvbookingUpsertWithWhereUniqueWithoutEventInput | EvbookingUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EvbookingCreateManyEventInputEnvelope
    set?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    disconnect?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    delete?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    connect?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    update?: EvbookingUpdateWithWhereUniqueWithoutEventInput | EvbookingUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EvbookingUpdateManyWithWhereWithoutEventInput | EvbookingUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EvbookingScalarWhereInput | EvbookingScalarWhereInput[]
  }

  export type EvbookingUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EvbookingCreateWithoutEventInput, EvbookingUncheckedCreateWithoutEventInput> | EvbookingCreateWithoutEventInput[] | EvbookingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EvbookingCreateOrConnectWithoutEventInput | EvbookingCreateOrConnectWithoutEventInput[]
    upsert?: EvbookingUpsertWithWhereUniqueWithoutEventInput | EvbookingUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EvbookingCreateManyEventInputEnvelope
    set?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    disconnect?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    delete?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    connect?: EvbookingWhereUniqueInput | EvbookingWhereUniqueInput[]
    update?: EvbookingUpdateWithWhereUniqueWithoutEventInput | EvbookingUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EvbookingUpdateManyWithWhereWithoutEventInput | EvbookingUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EvbookingScalarWhereInput | EvbookingScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutBookingInput = {
    create?: XOR<PropertyCreateWithoutBookingInput, PropertyUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBookingInput
    connect?: PropertyWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutBookingInput = {
    create?: XOR<BranchCreateWithoutBookingInput, BranchUncheckedCreateWithoutBookingInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBookingInput
    connect?: BranchWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutBookingInput = {
    create?: XOR<TableCreateWithoutBookingInput, TableUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TableCreateOrConnectWithoutBookingInput
    connect?: TableWhereUniqueInput
  }

  export type SeatBedCreateNestedOneWithoutBookingInput = {
    create?: XOR<SeatBedCreateWithoutBookingInput, SeatBedUncheckedCreateWithoutBookingInput>
    connectOrCreate?: SeatBedCreateOrConnectWithoutBookingInput
    connect?: SeatBedWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutBookingInput = {
    create?: XOR<OwnerCreateWithoutBookingInput, OwnerUncheckedCreateWithoutBookingInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBookingInput
    connect?: OwnerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingInput = {
    create?: XOR<UserCreateWithoutBookingInput, UserUncheckedCreateWithoutBookingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type PropertyUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PropertyCreateWithoutBookingInput, PropertyUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBookingInput
    upsert?: PropertyUpsertWithoutBookingInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutBookingInput, PropertyUpdateWithoutBookingInput>, PropertyUncheckedUpdateWithoutBookingInput>
  }

  export type BranchUpdateOneRequiredWithoutBookingNestedInput = {
    create?: XOR<BranchCreateWithoutBookingInput, BranchUncheckedCreateWithoutBookingInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBookingInput
    upsert?: BranchUpsertWithoutBookingInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBookingInput, BranchUpdateWithoutBookingInput>, BranchUncheckedUpdateWithoutBookingInput>
  }

  export type TableUpdateOneWithoutBookingNestedInput = {
    create?: XOR<TableCreateWithoutBookingInput, TableUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TableCreateOrConnectWithoutBookingInput
    upsert?: TableUpsertWithoutBookingInput
    disconnect?: TableWhereInput | boolean
    delete?: TableWhereInput | boolean
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutBookingInput, TableUpdateWithoutBookingInput>, TableUncheckedUpdateWithoutBookingInput>
  }

  export type SeatBedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<SeatBedCreateWithoutBookingInput, SeatBedUncheckedCreateWithoutBookingInput>
    connectOrCreate?: SeatBedCreateOrConnectWithoutBookingInput
    upsert?: SeatBedUpsertWithoutBookingInput
    disconnect?: SeatBedWhereInput | boolean
    delete?: SeatBedWhereInput | boolean
    connect?: SeatBedWhereUniqueInput
    update?: XOR<XOR<SeatBedUpdateToOneWithWhereWithoutBookingInput, SeatBedUpdateWithoutBookingInput>, SeatBedUncheckedUpdateWithoutBookingInput>
  }

  export type OwnerUpdateOneWithoutBookingNestedInput = {
    create?: XOR<OwnerCreateWithoutBookingInput, OwnerUncheckedCreateWithoutBookingInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBookingInput
    upsert?: OwnerUpsertWithoutBookingInput
    disconnect?: OwnerWhereInput | boolean
    delete?: OwnerWhereInput | boolean
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutBookingInput, OwnerUpdateWithoutBookingInput>, OwnerUncheckedUpdateWithoutBookingInput>
  }

  export type UserUpdateOneWithoutBookingNestedInput = {
    create?: XOR<UserCreateWithoutBookingInput, UserUncheckedCreateWithoutBookingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingInput
    upsert?: UserUpsertWithoutBookingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingInput, UserUpdateWithoutBookingInput>, UserUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type EventsCreateNestedOneWithoutEvbookingInput = {
    create?: XOR<EventsCreateWithoutEvbookingInput, EventsUncheckedCreateWithoutEvbookingInput>
    connectOrCreate?: EventsCreateOrConnectWithoutEvbookingInput
    connect?: EventsWhereUniqueInput
  }

  export type EventsUpdateOneRequiredWithoutEvbookingNestedInput = {
    create?: XOR<EventsCreateWithoutEvbookingInput, EventsUncheckedCreateWithoutEvbookingInput>
    connectOrCreate?: EventsCreateOrConnectWithoutEvbookingInput
    upsert?: EventsUpsertWithoutEvbookingInput
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutEvbookingInput, EventsUpdateWithoutEvbookingInput>, EventsUncheckedUpdateWithoutEvbookingInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumloggerTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.loggerType | EnumloggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumloggerTypeNullableFilter<$PrismaModel> | $Enums.loggerType | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumloggerTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loggerType | EnumloggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.loggerType[] | ListEnumloggerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumloggerTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.loggerType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumloggerTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumloggerTypeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableFilter<$PrismaModel> | $Enums.UserType | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumUserTypeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumBusinessCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessCategory | EnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessCategoryNullableFilter<$PrismaModel> | $Enums.BusinessCategory | null
  }

  export type NestedEnumBusinessCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessCategory | EnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessCategory[] | ListEnumBusinessCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.BusinessCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBusinessCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumBusinessCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumcompTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.compType | EnumcompTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompTypeNullableFilter<$PrismaModel> | $Enums.compType | null
  }

  export type NestedEnumcompTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.compType | EnumcompTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.compType[] | ListEnumcompTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.compType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcompTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumcompTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type RolePermissionCreateWithoutOwnerInput = {
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutOwnerInput = {
    id?: number
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    branchId: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutOwnerInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutOwnerInput, RolePermissionUncheckedCreateWithoutOwnerInput>
  }

  export type BranchCreateWithoutOwnerInput = {
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBranchesInput
    booking?: BookingCreateNestedManyWithoutBranchInput
    events?: EventsCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutOwnerInput = {
    id?: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutBranchInput
    events?: EventsUncheckedCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutOwnerInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutOwnerInput, BranchUncheckedCreateWithoutOwnerInput>
  }

  export type BranchCreateManyOwnerInputEnvelope = {
    data: BranchCreateManyOwnerInput | BranchCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutOwnerInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutOwnerInput = {
    id?: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyCreateManyOwnerInputEnvelope = {
    data: PropertyCreateManyOwnerInput | PropertyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutOwnerInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    branch: BranchCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutOwnerInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput>
  }

  export type BookingCreateManyOwnerInputEnvelope = {
    data: BookingCreateManyOwnerInput | BookingCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithoutOwnerInput = {
    update: XOR<RolePermissionUpdateWithoutOwnerInput, RolePermissionUncheckedUpdateWithoutOwnerInput>
    create: XOR<RolePermissionCreateWithoutOwnerInput, RolePermissionUncheckedCreateWithoutOwnerInput>
    where?: RolePermissionWhereInput
  }

  export type RolePermissionUpdateToOneWithWhereWithoutOwnerInput = {
    where?: RolePermissionWhereInput
    data: XOR<RolePermissionUpdateWithoutOwnerInput, RolePermissionUncheckedUpdateWithoutOwnerInput>
  }

  export type RolePermissionUpdateWithoutOwnerInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    branchId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutOwnerInput, BranchUncheckedUpdateWithoutOwnerInput>
    create: XOR<BranchCreateWithoutOwnerInput, BranchUncheckedCreateWithoutOwnerInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutOwnerInput, BranchUncheckedUpdateWithoutOwnerInput>
  }

  export type BranchUpdateManyWithWhereWithoutOwnerInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: IntFilter<"Branch"> | number
    ownerId?: IntFilter<"Branch"> | number
    propertyId?: IntFilter<"Branch"> | number
    branchName?: StringNullableFilter<"Branch"> | string | null
    slug?: StringNullableFilter<"Branch"> | string | null
    images?: JsonNullableFilter<"Branch">
    description?: StringNullableFilter<"Branch"> | string | null
    level?: StringNullableFilter<"Branch"> | string | null
    terms?: StringNullableFilter<"Branch"> | string | null
    city?: StringNullableFilter<"Branch"> | string | null
    area?: StringNullableFilter<"Branch"> | string | null
    country?: StringNullableFilter<"Branch"> | string | null
    amenities?: JsonNullableFilter<"Branch">
    amenity?: StringNullableListFilter<"Branch">
    latitude?: StringNullableFilter<"Branch"> | string | null
    longitude?: StringNullableFilter<"Branch"> | string | null
    location?: StringNullableFilter<"Branch"> | string | null
    optionalData?: JsonNullableFilter<"Branch">
    bookingCount?: IntFilter<"Branch"> | number
    status?: BoolFilter<"Branch"> | boolean
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutOwnerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: IntFilter<"Property"> | number
    ownerId?: IntFilter<"Property"> | number
    type?: EnumBusinessCategoryNullableFilter<"Property"> | $Enums.BusinessCategory | null
    listingName?: StringFilter<"Property"> | string
    slug?: StringNullableFilter<"Property"> | string | null
    title?: StringNullableFilter<"Property"> | string | null
    subTitle?: StringNullableFilter<"Property"> | string | null
    logo?: StringNullableFilter<"Property"> | string | null
    image?: JsonNullableFilter<"Property">
    description?: StringNullableFilter<"Property"> | string | null
    terms?: StringNullableFilter<"Property"> | string | null
    slot?: JsonNullableFilter<"Property">
    offday?: JsonNullableFilter<"Property">
    cuisines?: StringNullableListFilter<"Property">
    reservationCategory?: EnumCategoryNullableFilter<"Property"> | $Enums.Category | null
    sectSymb?: IntNullableFilter<"Property"> | number | null
    priority?: IntNullableFilter<"Property"> | number | null
    optionalData?: JsonNullableFilter<"Property">
    eventStatus?: BoolFilter<"Property"> | boolean
    status?: BoolFilter<"Property"> | boolean
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutOwnerInput, BookingUncheckedUpdateWithoutOwnerInput>
    create: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutOwnerInput, BookingUncheckedUpdateWithoutOwnerInput>
  }

  export type BookingUpdateManyWithWhereWithoutOwnerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    propertyId?: IntNullableFilter<"Booking"> | number | null
    branchId?: IntFilter<"Booking"> | number
    tableId?: IntNullableFilter<"Booking"> | number | null
    seatBedId?: IntNullableFilter<"Booking"> | number | null
    ownerId?: IntNullableFilter<"Booking"> | number | null
    customerId?: IntNullableFilter<"Booking"> | number | null
    customerName?: StringFilter<"Booking"> | string
    phoneNumber?: StringNullableFilter<"Booking"> | string | null
    startDate?: DateTimeFilter<"Booking"> | Date | string
    endDate?: DateTimeFilter<"Booking"> | Date | string
    slot?: StringNullableFilter<"Booking"> | string | null
    comment?: StringNullableFilter<"Booking"> | string | null
    customerRequest?: StringNullableFilter<"Booking"> | string | null
    cancelReason?: StringNullableFilter<"Booking"> | string | null
    guestNumber?: IntNullableFilter<"Booking"> | number | null
    amount?: IntFilter<"Booking"> | number
    vat?: IntFilter<"Booking"> | number
    discount?: IntFilter<"Booking"> | number
    grandTotal?: IntFilter<"Booking"> | number
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    bookingType?: StringNullableFilter<"Booking"> | string | null
    optionalData?: JsonNullableFilter<"Booking">
    deletedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BookingCreateWithoutCustomerInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    branch: BranchCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCustomerInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingCreateManyCustomerInputEnvelope = {
    data: BookingCreateManyCustomerInput | BookingCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
  }

  export type BookingUpdateManyWithWhereWithoutCustomerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type BranchCreateWithoutRolePermissionInput = {
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutBranchInput
    property: PropertyCreateNestedOneWithoutBranchesInput
    booking?: BookingCreateNestedManyWithoutBranchInput
    events?: EventsCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutRolePermissionInput = {
    id?: number
    ownerId: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutBranchInput
    events?: EventsUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutRolePermissionInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutRolePermissionInput, BranchUncheckedCreateWithoutRolePermissionInput>
  }

  export type OwnerCreateWithoutRolesInput = {
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedManyWithoutOwnerInput
    property?: PropertyCreateNestedManyWithoutOwnerInput
    booking?: BookingCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutRolesInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutOwnerInput
    property?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    booking?: BookingUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutRolesInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutRolesInput, OwnerUncheckedCreateWithoutRolesInput>
  }

  export type OwnerCreateManyRolesInputEnvelope = {
    data: OwnerCreateManyRolesInput | OwnerCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutRolePermissionInput = {
    update: XOR<BranchUpdateWithoutRolePermissionInput, BranchUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<BranchCreateWithoutRolePermissionInput, BranchUncheckedCreateWithoutRolePermissionInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutRolePermissionInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutRolePermissionInput, BranchUncheckedUpdateWithoutRolePermissionInput>
  }

  export type BranchUpdateWithoutRolePermissionInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutBranchNestedInput
    property?: PropertyUpdateOneRequiredWithoutBranchesNestedInput
    booking?: BookingUpdateManyWithoutBranchNestedInput
    events?: EventsUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    events?: EventsUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type OwnerUpsertWithWhereUniqueWithoutRolesInput = {
    where: OwnerWhereUniqueInput
    update: XOR<OwnerUpdateWithoutRolesInput, OwnerUncheckedUpdateWithoutRolesInput>
    create: XOR<OwnerCreateWithoutRolesInput, OwnerUncheckedCreateWithoutRolesInput>
  }

  export type OwnerUpdateWithWhereUniqueWithoutRolesInput = {
    where: OwnerWhereUniqueInput
    data: XOR<OwnerUpdateWithoutRolesInput, OwnerUncheckedUpdateWithoutRolesInput>
  }

  export type OwnerUpdateManyWithWhereWithoutRolesInput = {
    where: OwnerScalarWhereInput
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyWithoutRolesInput>
  }

  export type OwnerScalarWhereInput = {
    AND?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
    OR?: OwnerScalarWhereInput[]
    NOT?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
    id?: IntFilter<"Owner"> | number
    name?: StringNullableFilter<"Owner"> | string | null
    email?: StringNullableFilter<"Owner"> | string | null
    userType?: EnumUserTypeNullableFilter<"Owner"> | $Enums.UserType | null
    ownerId?: IntNullableFilter<"Owner"> | number | null
    roleId?: IntNullableFilter<"Owner"> | number | null
    birthDate?: DateTimeNullableFilter<"Owner"> | Date | string | null
    phoneNumber?: StringNullableFilter<"Owner"> | string | null
    country?: StringNullableFilter<"Owner"> | string | null
    city?: StringNullableFilter<"Owner"> | string | null
    location?: StringNullableFilter<"Owner"> | string | null
    residenceAddress?: StringNullableFilter<"Owner"> | string | null
    occupation?: StringNullableFilter<"Owner"> | string | null
    designation?: StringNullableFilter<"Owner"> | string | null
    nid?: StringNullableFilter<"Owner"> | string | null
    tin?: StringNullableFilter<"Owner"> | string | null
    havingBusiness?: BoolNullableFilter<"Owner"> | boolean | null
    password?: StringNullableFilter<"Owner"> | string | null
    loggerType?: EnumloggerTypeNullableFilter<"Owner"> | $Enums.loggerType | null
    isVerify?: BoolFilter<"Owner"> | boolean
    status?: BoolFilter<"Owner"> | boolean
    deletedAtAt?: DateTimeNullableFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    updatedAt?: DateTimeFilter<"Owner"> | Date | string
  }

  export type PropertyCreateWithoutWishListsInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutWishListsInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutWishListsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutWishListsInput, PropertyUncheckedCreateWithoutWishListsInput>
  }

  export type PropertyUpsertWithoutWishListsInput = {
    update: XOR<PropertyUpdateWithoutWishListsInput, PropertyUncheckedUpdateWithoutWishListsInput>
    create: XOR<PropertyCreateWithoutWishListsInput, PropertyUncheckedCreateWithoutWishListsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutWishListsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutWishListsInput, PropertyUncheckedUpdateWithoutWishListsInput>
  }

  export type PropertyUpdateWithoutWishListsInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutWishListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type OwnerCreateWithoutPropertyInput = {
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedOneWithoutOwnerInput
    branch?: BranchCreateNestedManyWithoutOwnerInput
    booking?: BookingCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutPropertyInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    roleId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutOwnerInput
    booking?: BookingUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutPropertyInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutPropertyInput, OwnerUncheckedCreateWithoutPropertyInput>
  }

  export type TableCreateWithoutPropertyInput = {
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutPropertyInput = {
    id?: number
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutPropertyInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutPropertyInput, TableUncheckedCreateWithoutPropertyInput>
  }

  export type TableCreateManyPropertyInputEnvelope = {
    data: TableCreateManyPropertyInput | TableCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type SeatBedCreateWithoutPropertyInput = {
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedManyWithoutSeatBedInput
  }

  export type SeatBedUncheckedCreateWithoutPropertyInput = {
    id?: number
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutSeatBedInput
  }

  export type SeatBedCreateOrConnectWithoutPropertyInput = {
    where: SeatBedWhereUniqueInput
    create: XOR<SeatBedCreateWithoutPropertyInput, SeatBedUncheckedCreateWithoutPropertyInput>
  }

  export type SeatBedCreateManyPropertyInputEnvelope = {
    data: SeatBedCreateManyPropertyInput | SeatBedCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutPropertyInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPropertyInput = {
    id?: number
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPropertyInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput>
  }

  export type BookingCreateManyPropertyInputEnvelope = {
    data: BookingCreateManyPropertyInput | BookingCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type wishListCreateWithoutPropertyInput = {
    type?: $Enums.BusinessCategory | null
    userId?: number | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wishListUncheckedCreateWithoutPropertyInput = {
    id?: number
    type?: $Enums.BusinessCategory | null
    userId?: number | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wishListCreateOrConnectWithoutPropertyInput = {
    where: wishListWhereUniqueInput
    create: XOR<wishListCreateWithoutPropertyInput, wishListUncheckedCreateWithoutPropertyInput>
  }

  export type wishListCreateManyPropertyInputEnvelope = {
    data: wishListCreateManyPropertyInput | wishListCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type FoodCreateWithoutPropertyInput = {
    name: string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodUncheckedCreateWithoutPropertyInput = {
    id?: number
    name: string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCreateOrConnectWithoutPropertyInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutPropertyInput, FoodUncheckedCreateWithoutPropertyInput>
  }

  export type FoodCreateManyPropertyInputEnvelope = {
    data: FoodCreateManyPropertyInput | FoodCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutPropertyInput = {
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutBranchInput
    booking?: BookingCreateNestedManyWithoutBranchInput
    events?: EventsCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPropertyInput = {
    id?: number
    ownerId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutBranchInput
    events?: EventsUncheckedCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPropertyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPropertyInput, BranchUncheckedCreateWithoutPropertyInput>
  }

  export type BranchCreateManyPropertyInputEnvelope = {
    data: BranchCreateManyPropertyInput | BranchCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type EventsCreateWithoutPropertyInput = {
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutEventsInput
    evbooking?: EvbookingCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutPropertyInput = {
    id?: number
    branchId?: number | null
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    evbooking?: EvbookingUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutPropertyInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutPropertyInput, EventsUncheckedCreateWithoutPropertyInput>
  }

  export type EventsCreateManyPropertyInputEnvelope = {
    data: EventsCreateManyPropertyInput | EventsCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type OwnerUpsertWithoutPropertyInput = {
    update: XOR<OwnerUpdateWithoutPropertyInput, OwnerUncheckedUpdateWithoutPropertyInput>
    create: XOR<OwnerCreateWithoutPropertyInput, OwnerUncheckedCreateWithoutPropertyInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutPropertyInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutPropertyInput, OwnerUncheckedUpdateWithoutPropertyInput>
  }

  export type OwnerUpdateWithoutPropertyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateOneWithoutOwnerNestedInput
    branch?: BranchUpdateManyWithoutOwnerNestedInput
    booking?: BookingUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutOwnerNestedInput
    booking?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type TableUpsertWithWhereUniqueWithoutPropertyInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutPropertyInput, TableUncheckedUpdateWithoutPropertyInput>
    create: XOR<TableCreateWithoutPropertyInput, TableUncheckedCreateWithoutPropertyInput>
  }

  export type TableUpdateWithWhereUniqueWithoutPropertyInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutPropertyInput, TableUncheckedUpdateWithoutPropertyInput>
  }

  export type TableUpdateManyWithWhereWithoutPropertyInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutPropertyInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: IntFilter<"Table"> | number
    propertyId?: IntFilter<"Table"> | number
    type?: EnumcompTypeNullableFilter<"Table"> | $Enums.compType | null
    capacity?: IntNullableFilter<"Table"> | number | null
    position?: StringFilter<"Table"> | string
    size?: StringFilter<"Table"> | string
    image?: StringNullableFilter<"Table"> | string | null
    splitable?: BoolFilter<"Table"> | boolean
    ryservable?: BoolFilter<"Table"> | boolean
    status?: BoolFilter<"Table"> | boolean
    deletedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
  }

  export type SeatBedUpsertWithWhereUniqueWithoutPropertyInput = {
    where: SeatBedWhereUniqueInput
    update: XOR<SeatBedUpdateWithoutPropertyInput, SeatBedUncheckedUpdateWithoutPropertyInput>
    create: XOR<SeatBedCreateWithoutPropertyInput, SeatBedUncheckedCreateWithoutPropertyInput>
  }

  export type SeatBedUpdateWithWhereUniqueWithoutPropertyInput = {
    where: SeatBedWhereUniqueInput
    data: XOR<SeatBedUpdateWithoutPropertyInput, SeatBedUncheckedUpdateWithoutPropertyInput>
  }

  export type SeatBedUpdateManyWithWhereWithoutPropertyInput = {
    where: SeatBedScalarWhereInput
    data: XOR<SeatBedUpdateManyMutationInput, SeatBedUncheckedUpdateManyWithoutPropertyInput>
  }

  export type SeatBedScalarWhereInput = {
    AND?: SeatBedScalarWhereInput | SeatBedScalarWhereInput[]
    OR?: SeatBedScalarWhereInput[]
    NOT?: SeatBedScalarWhereInput | SeatBedScalarWhereInput[]
    id?: IntFilter<"SeatBed"> | number
    propertyId?: IntFilter<"SeatBed"> | number
    type?: EnumcompTypeNullableFilter<"SeatBed"> | $Enums.compType | null
    roomNo?: StringFilter<"SeatBed"> | string
    breakfast?: StringFilter<"SeatBed"> | string
    image?: StringNullableFilter<"SeatBed"> | string | null
    accomodationCapacity?: StringFilter<"SeatBed"> | string
    extraBedPolicy?: StringFilter<"SeatBed"> | string
    status?: BoolFilter<"SeatBed"> | boolean
    deletedAt?: DateTimeNullableFilter<"SeatBed"> | Date | string | null
    createdAt?: DateTimeFilter<"SeatBed"> | Date | string
    updatedAt?: DateTimeFilter<"SeatBed"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutPropertyInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPropertyInput, BookingUncheckedUpdateWithoutPropertyInput>
    create: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPropertyInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPropertyInput, BookingUncheckedUpdateWithoutPropertyInput>
  }

  export type BookingUpdateManyWithWhereWithoutPropertyInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPropertyInput>
  }

  export type wishListUpsertWithWhereUniqueWithoutPropertyInput = {
    where: wishListWhereUniqueInput
    update: XOR<wishListUpdateWithoutPropertyInput, wishListUncheckedUpdateWithoutPropertyInput>
    create: XOR<wishListCreateWithoutPropertyInput, wishListUncheckedCreateWithoutPropertyInput>
  }

  export type wishListUpdateWithWhereUniqueWithoutPropertyInput = {
    where: wishListWhereUniqueInput
    data: XOR<wishListUpdateWithoutPropertyInput, wishListUncheckedUpdateWithoutPropertyInput>
  }

  export type wishListUpdateManyWithWhereWithoutPropertyInput = {
    where: wishListScalarWhereInput
    data: XOR<wishListUpdateManyMutationInput, wishListUncheckedUpdateManyWithoutPropertyInput>
  }

  export type wishListScalarWhereInput = {
    AND?: wishListScalarWhereInput | wishListScalarWhereInput[]
    OR?: wishListScalarWhereInput[]
    NOT?: wishListScalarWhereInput | wishListScalarWhereInput[]
    id?: IntFilter<"wishList"> | number
    type?: EnumBusinessCategoryNullableFilter<"wishList"> | $Enums.BusinessCategory | null
    userId?: IntNullableFilter<"wishList"> | number | null
    propertyId?: IntNullableFilter<"wishList"> | number | null
    status?: BoolFilter<"wishList"> | boolean
    deletedAt?: DateTimeNullableFilter<"wishList"> | Date | string | null
    createdAt?: DateTimeFilter<"wishList"> | Date | string
    updatedAt?: DateTimeFilter<"wishList"> | Date | string
  }

  export type FoodUpsertWithWhereUniqueWithoutPropertyInput = {
    where: FoodWhereUniqueInput
    update: XOR<FoodUpdateWithoutPropertyInput, FoodUncheckedUpdateWithoutPropertyInput>
    create: XOR<FoodCreateWithoutPropertyInput, FoodUncheckedCreateWithoutPropertyInput>
  }

  export type FoodUpdateWithWhereUniqueWithoutPropertyInput = {
    where: FoodWhereUniqueInput
    data: XOR<FoodUpdateWithoutPropertyInput, FoodUncheckedUpdateWithoutPropertyInput>
  }

  export type FoodUpdateManyWithWhereWithoutPropertyInput = {
    where: FoodScalarWhereInput
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyWithoutPropertyInput>
  }

  export type FoodScalarWhereInput = {
    AND?: FoodScalarWhereInput | FoodScalarWhereInput[]
    OR?: FoodScalarWhereInput[]
    NOT?: FoodScalarWhereInput | FoodScalarWhereInput[]
    id?: IntFilter<"Food"> | number
    name?: StringFilter<"Food"> | string
    images?: JsonNullableFilter<"Food">
    optionalData?: JsonNullableFilter<"Food">
    rating?: FloatFilter<"Food"> | number
    propertyId?: IntFilter<"Food"> | number
    price?: JsonNullableFilter<"Food">
    description?: StringNullableFilter<"Food"> | string | null
    status?: BoolFilter<"Food"> | boolean
    deletedAt?: DateTimeNullableFilter<"Food"> | Date | string | null
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
  }

  export type BranchUpsertWithWhereUniqueWithoutPropertyInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutPropertyInput, BranchUncheckedUpdateWithoutPropertyInput>
    create: XOR<BranchCreateWithoutPropertyInput, BranchUncheckedCreateWithoutPropertyInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutPropertyInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutPropertyInput, BranchUncheckedUpdateWithoutPropertyInput>
  }

  export type BranchUpdateManyWithWhereWithoutPropertyInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutPropertyInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutPropertyInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutPropertyInput, EventsUncheckedUpdateWithoutPropertyInput>
    create: XOR<EventsCreateWithoutPropertyInput, EventsUncheckedCreateWithoutPropertyInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutPropertyInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutPropertyInput, EventsUncheckedUpdateWithoutPropertyInput>
  }

  export type EventsUpdateManyWithWhereWithoutPropertyInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutPropertyInput>
  }

  export type EventsScalarWhereInput = {
    AND?: EventsScalarWhereInput | EventsScalarWhereInput[]
    OR?: EventsScalarWhereInput[]
    NOT?: EventsScalarWhereInput | EventsScalarWhereInput[]
    id?: IntFilter<"Events"> | number
    propertyId?: IntFilter<"Events"> | number
    branchId?: IntNullableFilter<"Events"> | number | null
    location?: StringNullableFilter<"Events"> | string | null
    mapLocation?: StringNullableFilter<"Events"> | string | null
    address?: StringNullableFilter<"Events"> | string | null
    capacity?: IntFilter<"Events"> | number
    startDate?: DateTimeFilter<"Events"> | Date | string
    endDate?: DateTimeNullableFilter<"Events"> | Date | string | null
    status?: BoolFilter<"Events"> | boolean
    deletedAt?: DateTimeNullableFilter<"Events"> | Date | string | null
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Events"> | Date | string | null
  }

  export type OwnerCreateWithoutBranchInput = {
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedOneWithoutOwnerInput
    property?: PropertyCreateNestedManyWithoutOwnerInput
    booking?: BookingCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutBranchInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    roleId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    booking?: BookingUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutBranchInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutBranchInput, OwnerUncheckedCreateWithoutBranchInput>
  }

  export type PropertyCreateWithoutBranchesInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutBranchesInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutBranchesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutBranchesInput, PropertyUncheckedCreateWithoutBranchesInput>
  }

  export type BookingCreateWithoutBranchInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBranchInput = {
    id?: number
    propertyId?: number | null
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBranchInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput>
  }

  export type BookingCreateManyBranchInputEnvelope = {
    data: BookingCreateManyBranchInput | BookingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EventsCreateWithoutBranchInput = {
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutEventInput
    evbooking?: EvbookingCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutBranchInput = {
    id?: number
    propertyId: number
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    evbooking?: EvbookingUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutBranchInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutBranchInput, EventsUncheckedCreateWithoutBranchInput>
  }

  export type EventsCreateManyBranchInputEnvelope = {
    data: EventsCreateManyBranchInput | EventsCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutBranchInput = {
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: OwnerCreateNestedManyWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutBranchInput = {
    id?: number
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: OwnerUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolePermissionCreateOrConnectWithoutBranchInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutBranchInput, RolePermissionUncheckedCreateWithoutBranchInput>
  }

  export type RolePermissionCreateManyBranchInputEnvelope = {
    data: RolePermissionCreateManyBranchInput | RolePermissionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type OwnerUpsertWithoutBranchInput = {
    update: XOR<OwnerUpdateWithoutBranchInput, OwnerUncheckedUpdateWithoutBranchInput>
    create: XOR<OwnerCreateWithoutBranchInput, OwnerUncheckedCreateWithoutBranchInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutBranchInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutBranchInput, OwnerUncheckedUpdateWithoutBranchInput>
  }

  export type OwnerUpdateWithoutBranchInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateOneWithoutOwnerNestedInput
    property?: PropertyUpdateManyWithoutOwnerNestedInput
    booking?: BookingUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    booking?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PropertyUpsertWithoutBranchesInput = {
    update: XOR<PropertyUpdateWithoutBranchesInput, PropertyUncheckedUpdateWithoutBranchesInput>
    create: XOR<PropertyCreateWithoutBranchesInput, PropertyUncheckedCreateWithoutBranchesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutBranchesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutBranchesInput, PropertyUncheckedUpdateWithoutBranchesInput>
  }

  export type PropertyUpdateWithoutBranchesInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutBranchInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBranchInput, BookingUncheckedUpdateWithoutBranchInput>
    create: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBranchInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBranchInput, BookingUncheckedUpdateWithoutBranchInput>
  }

  export type BookingUpdateManyWithWhereWithoutBranchInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBranchInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutBranchInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutBranchInput, EventsUncheckedUpdateWithoutBranchInput>
    create: XOR<EventsCreateWithoutBranchInput, EventsUncheckedCreateWithoutBranchInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutBranchInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutBranchInput, EventsUncheckedUpdateWithoutBranchInput>
  }

  export type EventsUpdateManyWithWhereWithoutBranchInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutBranchInput>
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutBranchInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutBranchInput, RolePermissionUncheckedUpdateWithoutBranchInput>
    create: XOR<RolePermissionCreateWithoutBranchInput, RolePermissionUncheckedCreateWithoutBranchInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutBranchInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutBranchInput, RolePermissionUncheckedUpdateWithoutBranchInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutBranchInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutBranchInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleName?: StringFilter<"RolePermission"> | string
    permissions?: StringNullableListFilter<"RolePermission">
    branchId?: IntFilter<"RolePermission"> | number
    status?: BoolFilter<"RolePermission"> | boolean
    deletedAt?: DateTimeNullableFilter<"RolePermission"> | Date | string | null
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type PropertyCreateWithoutTablesInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutTablesInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutTablesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutTablesInput, PropertyUncheckedCreateWithoutTablesInput>
  }

  export type BookingCreateWithoutTableInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    branch: BranchCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTableInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTableInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTableInput, BookingUncheckedCreateWithoutTableInput>
  }

  export type BookingCreateManyTableInputEnvelope = {
    data: BookingCreateManyTableInput | BookingCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutTablesInput = {
    update: XOR<PropertyUpdateWithoutTablesInput, PropertyUncheckedUpdateWithoutTablesInput>
    create: XOR<PropertyCreateWithoutTablesInput, PropertyUncheckedCreateWithoutTablesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutTablesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutTablesInput, PropertyUncheckedUpdateWithoutTablesInput>
  }

  export type PropertyUpdateWithoutTablesInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutTablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutTableInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTableInput, BookingUncheckedUpdateWithoutTableInput>
    create: XOR<BookingCreateWithoutTableInput, BookingUncheckedCreateWithoutTableInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTableInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTableInput, BookingUncheckedUpdateWithoutTableInput>
  }

  export type BookingUpdateManyWithWhereWithoutTableInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTableInput>
  }

  export type PropertyCreateWithoutSeatBedInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutSeatBedInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutSeatBedInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutSeatBedInput, PropertyUncheckedCreateWithoutSeatBedInput>
  }

  export type BookingCreateWithoutSeatBedInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    branch: BranchCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutSeatBedInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutSeatBedInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutSeatBedInput, BookingUncheckedCreateWithoutSeatBedInput>
  }

  export type BookingCreateManySeatBedInputEnvelope = {
    data: BookingCreateManySeatBedInput | BookingCreateManySeatBedInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutSeatBedInput = {
    update: XOR<PropertyUpdateWithoutSeatBedInput, PropertyUncheckedUpdateWithoutSeatBedInput>
    create: XOR<PropertyCreateWithoutSeatBedInput, PropertyUncheckedCreateWithoutSeatBedInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutSeatBedInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutSeatBedInput, PropertyUncheckedUpdateWithoutSeatBedInput>
  }

  export type PropertyUpdateWithoutSeatBedInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutSeatBedInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutSeatBedInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutSeatBedInput, BookingUncheckedUpdateWithoutSeatBedInput>
    create: XOR<BookingCreateWithoutSeatBedInput, BookingUncheckedCreateWithoutSeatBedInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutSeatBedInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutSeatBedInput, BookingUncheckedUpdateWithoutSeatBedInput>
  }

  export type BookingUpdateManyWithWhereWithoutSeatBedInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutSeatBedInput>
  }

  export type PropertyCreateWithoutFoodInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutFoodInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutFoodInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutFoodInput, PropertyUncheckedCreateWithoutFoodInput>
  }

  export type PropertyUpsertWithoutFoodInput = {
    update: XOR<PropertyUpdateWithoutFoodInput, PropertyUncheckedUpdateWithoutFoodInput>
    create: XOR<PropertyCreateWithoutFoodInput, PropertyUncheckedCreateWithoutFoodInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutFoodInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutFoodInput, PropertyUncheckedUpdateWithoutFoodInput>
  }

  export type PropertyUpdateWithoutFoodInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutFoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutEventInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    booking?: BookingCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutEventInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    booking?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutEventInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutEventInput, PropertyUncheckedCreateWithoutEventInput>
  }

  export type BranchCreateWithoutEventsInput = {
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutBranchInput
    property: PropertyCreateNestedOneWithoutBranchesInput
    booking?: BookingCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEventsInput = {
    id?: number
    ownerId: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEventsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEventsInput, BranchUncheckedCreateWithoutEventsInput>
  }

  export type EvbookingCreateWithoutEventInput = {
    username: string
    phoneNumber: string
    email?: string | null
    address?: string | null
    ticketNumber: string
    person?: number
    price?: number
    amount?: number
    vat?: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date | string
    status?: boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt: Date | string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvbookingUncheckedCreateWithoutEventInput = {
    id?: number
    username: string
    phoneNumber: string
    email?: string | null
    address?: string | null
    ticketNumber: string
    person?: number
    price?: number
    amount?: number
    vat?: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date | string
    status?: boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt: Date | string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvbookingCreateOrConnectWithoutEventInput = {
    where: EvbookingWhereUniqueInput
    create: XOR<EvbookingCreateWithoutEventInput, EvbookingUncheckedCreateWithoutEventInput>
  }

  export type EvbookingCreateManyEventInputEnvelope = {
    data: EvbookingCreateManyEventInput | EvbookingCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutEventInput = {
    update: XOR<PropertyUpdateWithoutEventInput, PropertyUncheckedUpdateWithoutEventInput>
    create: XOR<PropertyCreateWithoutEventInput, PropertyUncheckedCreateWithoutEventInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutEventInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutEventInput, PropertyUncheckedUpdateWithoutEventInput>
  }

  export type PropertyUpdateWithoutEventInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BranchUpsertWithoutEventsInput = {
    update: XOR<BranchUpdateWithoutEventsInput, BranchUncheckedUpdateWithoutEventsInput>
    create: XOR<BranchCreateWithoutEventsInput, BranchUncheckedCreateWithoutEventsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEventsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEventsInput, BranchUncheckedUpdateWithoutEventsInput>
  }

  export type BranchUpdateWithoutEventsInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutBranchNestedInput
    property?: PropertyUpdateOneRequiredWithoutBranchesNestedInput
    booking?: BookingUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EvbookingUpsertWithWhereUniqueWithoutEventInput = {
    where: EvbookingWhereUniqueInput
    update: XOR<EvbookingUpdateWithoutEventInput, EvbookingUncheckedUpdateWithoutEventInput>
    create: XOR<EvbookingCreateWithoutEventInput, EvbookingUncheckedCreateWithoutEventInput>
  }

  export type EvbookingUpdateWithWhereUniqueWithoutEventInput = {
    where: EvbookingWhereUniqueInput
    data: XOR<EvbookingUpdateWithoutEventInput, EvbookingUncheckedUpdateWithoutEventInput>
  }

  export type EvbookingUpdateManyWithWhereWithoutEventInput = {
    where: EvbookingScalarWhereInput
    data: XOR<EvbookingUpdateManyMutationInput, EvbookingUncheckedUpdateManyWithoutEventInput>
  }

  export type EvbookingScalarWhereInput = {
    AND?: EvbookingScalarWhereInput | EvbookingScalarWhereInput[]
    OR?: EvbookingScalarWhereInput[]
    NOT?: EvbookingScalarWhereInput | EvbookingScalarWhereInput[]
    id?: IntFilter<"Evbooking"> | number
    username?: StringFilter<"Evbooking"> | string
    phoneNumber?: StringFilter<"Evbooking"> | string
    email?: StringNullableFilter<"Evbooking"> | string | null
    address?: StringNullableFilter<"Evbooking"> | string | null
    ticketNumber?: StringFilter<"Evbooking"> | string
    person?: IntFilter<"Evbooking"> | number
    price?: IntFilter<"Evbooking"> | number
    amount?: FloatFilter<"Evbooking"> | number
    vat?: FloatFilter<"Evbooking"> | number
    payStatus?: EnumPaymentStatusFilter<"Evbooking"> | $Enums.PaymentStatus
    eventDate?: DateTimeFilter<"Evbooking"> | Date | string
    eventId?: IntFilter<"Evbooking"> | number
    status?: BoolFilter<"Evbooking"> | boolean
    optionalData?: JsonNullableFilter<"Evbooking">
    issueAt?: DateTimeFilter<"Evbooking"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Evbooking"> | Date | string | null
    createdAt?: DateTimeFilter<"Evbooking"> | Date | string
    updatedAt?: DateTimeFilter<"Evbooking"> | Date | string
  }

  export type PropertyCreateWithoutBookingInput = {
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPropertyInput
    tables?: TableCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListCreateNestedManyWithoutPropertyInput
    food?: FoodCreateNestedManyWithoutPropertyInput
    branches?: BranchCreateNestedManyWithoutPropertyInput
    event?: EventsCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutBookingInput = {
    id?: number
    ownerId: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutPropertyInput
    seatBed?: SeatBedUncheckedCreateNestedManyWithoutPropertyInput
    wishLists?: wishListUncheckedCreateNestedManyWithoutPropertyInput
    food?: FoodUncheckedCreateNestedManyWithoutPropertyInput
    branches?: BranchUncheckedCreateNestedManyWithoutPropertyInput
    event?: EventsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutBookingInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutBookingInput, PropertyUncheckedCreateWithoutBookingInput>
  }

  export type BranchCreateWithoutBookingInput = {
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutBranchInput
    property: PropertyCreateNestedOneWithoutBranchesInput
    events?: EventsCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBookingInput = {
    id?: number
    ownerId: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventsUncheckedCreateNestedManyWithoutBranchInput
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBookingInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBookingInput, BranchUncheckedCreateWithoutBookingInput>
  }

  export type TableCreateWithoutBookingInput = {
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutTablesInput
  }

  export type TableUncheckedCreateWithoutBookingInput = {
    id?: number
    propertyId: number
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableCreateOrConnectWithoutBookingInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutBookingInput, TableUncheckedCreateWithoutBookingInput>
  }

  export type SeatBedCreateWithoutBookingInput = {
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutSeatBedInput
  }

  export type SeatBedUncheckedCreateWithoutBookingInput = {
    id?: number
    propertyId: number
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatBedCreateOrConnectWithoutBookingInput = {
    where: SeatBedWhereUniqueInput
    create: XOR<SeatBedCreateWithoutBookingInput, SeatBedUncheckedCreateWithoutBookingInput>
  }

  export type OwnerCreateWithoutBookingInput = {
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedOneWithoutOwnerInput
    branch?: BranchCreateNestedManyWithoutOwnerInput
    property?: PropertyCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutBookingInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    roleId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutOwnerInput
    property?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutBookingInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutBookingInput, OwnerUncheckedCreateWithoutBookingInput>
  }

  export type UserCreateWithoutBookingInput = {
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userType?: $Enums.UserType | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    picture?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: number | null
    tin?: string | null
    password?: string | null
    otp?: number | null
    otpExpireAt?: Date | string | null
    isVerify?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutBookingInput = {
    id?: number
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userType?: $Enums.UserType | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    picture?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: number | null
    tin?: string | null
    password?: string | null
    otp?: number | null
    otpExpireAt?: Date | string | null
    isVerify?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutBookingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingInput, UserUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    paymentDate?: Date | string | null
    paymentInfo?: string | null
    status: $Enums.PaymentStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: number
    paymentDate?: Date | string | null
    paymentInfo?: string | null
    status: $Enums.PaymentStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutBookingInput = {
    update: XOR<PropertyUpdateWithoutBookingInput, PropertyUncheckedUpdateWithoutBookingInput>
    create: XOR<PropertyCreateWithoutBookingInput, PropertyUncheckedCreateWithoutBookingInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutBookingInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutBookingInput, PropertyUncheckedUpdateWithoutBookingInput>
  }

  export type PropertyUpdateWithoutBookingInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPropertyNestedInput
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BranchUpsertWithoutBookingInput = {
    update: XOR<BranchUpdateWithoutBookingInput, BranchUncheckedUpdateWithoutBookingInput>
    create: XOR<BranchCreateWithoutBookingInput, BranchUncheckedCreateWithoutBookingInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBookingInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBookingInput, BranchUncheckedUpdateWithoutBookingInput>
  }

  export type BranchUpdateWithoutBookingInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutBranchNestedInput
    property?: PropertyUpdateOneRequiredWithoutBranchesNestedInput
    events?: EventsUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventsUncheckedUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TableUpsertWithoutBookingInput = {
    update: XOR<TableUpdateWithoutBookingInput, TableUncheckedUpdateWithoutBookingInput>
    create: XOR<TableCreateWithoutBookingInput, TableUncheckedCreateWithoutBookingInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutBookingInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutBookingInput, TableUncheckedUpdateWithoutBookingInput>
  }

  export type TableUpdateWithoutBookingInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutTablesNestedInput
  }

  export type TableUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatBedUpsertWithoutBookingInput = {
    update: XOR<SeatBedUpdateWithoutBookingInput, SeatBedUncheckedUpdateWithoutBookingInput>
    create: XOR<SeatBedCreateWithoutBookingInput, SeatBedUncheckedCreateWithoutBookingInput>
    where?: SeatBedWhereInput
  }

  export type SeatBedUpdateToOneWithWhereWithoutBookingInput = {
    where?: SeatBedWhereInput
    data: XOR<SeatBedUpdateWithoutBookingInput, SeatBedUncheckedUpdateWithoutBookingInput>
  }

  export type SeatBedUpdateWithoutBookingInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutSeatBedNestedInput
  }

  export type SeatBedUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerUpsertWithoutBookingInput = {
    update: XOR<OwnerUpdateWithoutBookingInput, OwnerUncheckedUpdateWithoutBookingInput>
    create: XOR<OwnerCreateWithoutBookingInput, OwnerUncheckedCreateWithoutBookingInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutBookingInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutBookingInput, OwnerUncheckedUpdateWithoutBookingInput>
  }

  export type OwnerUpdateWithoutBookingInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateOneWithoutOwnerNestedInput
    branch?: BranchUpdateManyWithoutOwnerNestedInput
    property?: PropertyUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutOwnerNestedInput
    property?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithoutBookingInput = {
    update: XOR<UserUpdateWithoutBookingInput, UserUncheckedUpdateWithoutBookingInput>
    create: XOR<UserCreateWithoutBookingInput, UserUncheckedCreateWithoutBookingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingInput, UserUncheckedUpdateWithoutBookingInput>
  }

  export type UserUpdateWithoutBookingInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableIntFieldUpdateOperationsInput | number | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableIntFieldUpdateOperationsInput | number | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntFilter<"Payment"> | number
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentInfo?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type BookingCreateWithoutPaymentsInput = {
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutBookingInput
    branch: BranchCreateNestedOneWithoutBookingInput
    table?: TableCreateNestedOneWithoutBookingInput
    seatBed?: SeatBedCreateNestedOneWithoutBookingInput
    owner?: OwnerCreateNestedOneWithoutBookingInput
    customer?: UserCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateWithoutEvbookingInput = {
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    property: PropertyCreateNestedOneWithoutEventInput
    branch?: BranchCreateNestedOneWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutEvbookingInput = {
    id?: number
    propertyId: number
    branchId?: number | null
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type EventsCreateOrConnectWithoutEvbookingInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutEvbookingInput, EventsUncheckedCreateWithoutEvbookingInput>
  }

  export type EventsUpsertWithoutEvbookingInput = {
    update: XOR<EventsUpdateWithoutEvbookingInput, EventsUncheckedUpdateWithoutEvbookingInput>
    create: XOR<EventsCreateWithoutEvbookingInput, EventsUncheckedCreateWithoutEvbookingInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutEvbookingInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutEvbookingInput, EventsUncheckedUpdateWithoutEvbookingInput>
  }

  export type EventsUpdateWithoutEvbookingInput = {
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutEventNestedInput
    branch?: BranchUpdateOneWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutEvbookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BranchCreateManyOwnerInput = {
    id?: number
    propertyId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCreateManyOwnerInput = {
    id?: number
    type?: $Enums.BusinessCategory | null
    listingName: string
    slug?: string | null
    title?: string | null
    subTitle?: string | null
    logo?: string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    terms?: string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyCreatecuisinesInput | string[]
    reservationCategory?: $Enums.Category | null
    sectSymb?: number | null
    priority?: number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyOwnerInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateWithoutOwnerInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBranchesNestedInput
    booking?: BookingUpdateManyWithoutBranchNestedInput
    events?: EventsUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    events?: EventsUncheckedUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutOwnerInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUpdateManyWithoutPropertyNestedInput
    food?: FoodUpdateManyWithoutPropertyNestedInput
    branches?: BranchUpdateManyWithoutPropertyNestedInput
    event?: EventsUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutPropertyNestedInput
    seatBed?: SeatBedUncheckedUpdateManyWithoutPropertyNestedInput
    booking?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    wishLists?: wishListUncheckedUpdateManyWithoutPropertyNestedInput
    food?: FoodUncheckedUpdateManyWithoutPropertyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutPropertyNestedInput
    event?: EventsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    listingName?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    slot?: NullableJsonNullValueInput | InputJsonValue
    offday?: NullableJsonNullValueInput | InputJsonValue
    cuisines?: PropertyUpdatecuisinesInput | string[]
    reservationCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    sectSymb?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    eventStatus?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutOwnerInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyCustomerInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutCustomerInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerCreateManyRolesInput = {
    id?: number
    name?: string | null
    email?: string | null
    userType?: $Enums.UserType | null
    ownerId?: number | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    country?: string | null
    city?: string | null
    location?: string | null
    residenceAddress?: string | null
    occupation?: string | null
    designation?: string | null
    nid?: string | null
    tin?: string | null
    havingBusiness?: boolean | null
    password?: string | null
    loggerType?: $Enums.loggerType | null
    isVerify?: boolean
    status?: boolean
    deletedAtAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerUpdateWithoutRolesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateManyWithoutOwnerNestedInput
    property?: PropertyUpdateManyWithoutOwnerNestedInput
    booking?: BookingUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutOwnerNestedInput
    property?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    booking?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    residenceAddress?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    havingBusiness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loggerType?: NullableEnumloggerTypeFieldUpdateOperationsInput | $Enums.loggerType | null
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAtAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateManyPropertyInput = {
    id?: number
    type?: $Enums.compType | null
    capacity?: number | null
    position: string
    size: string
    image?: string | null
    splitable?: boolean
    ryservable?: boolean
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatBedCreateManyPropertyInput = {
    id?: number
    type?: $Enums.compType | null
    roomNo: string
    breakfast: string
    image?: string | null
    accomodationCapacity: string
    extraBedPolicy: string
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyPropertyInput = {
    id?: number
    branchId: number
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wishListCreateManyPropertyInput = {
    id?: number
    type?: $Enums.BusinessCategory | null
    userId?: number | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCreateManyPropertyInput = {
    id?: number
    name: string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchCreateManyPropertyInput = {
    id?: number
    ownerId: number
    branchName?: string | null
    slug?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    level?: string | null
    terms?: string | null
    city?: string | null
    area?: string | null
    country?: string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchCreateamenityInput | string[]
    latitude?: string | null
    longitude?: string | null
    location?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: number
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsCreateManyPropertyInput = {
    id?: number
    branchId?: number | null
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TableUpdateWithoutPropertyInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    splitable?: BoolFieldUpdateOperationsInput | boolean
    ryservable?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatBedUpdateWithoutPropertyInput = {
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateManyWithoutSeatBedNestedInput
  }

  export type SeatBedUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutSeatBedNestedInput
  }

  export type SeatBedUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumcompTypeFieldUpdateOperationsInput | $Enums.compType | null
    roomNo?: StringFieldUpdateOperationsInput | string
    breakfast?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accomodationCapacity?: StringFieldUpdateOperationsInput | string
    extraBedPolicy?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutPropertyInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishListUpdateWithoutPropertyInput = {
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishListUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wishListUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumBusinessCategoryFieldUpdateOperationsInput | $Enums.BusinessCategory | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodUpdateWithoutPropertyInput = {
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    price?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpdateWithoutPropertyInput = {
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutBranchNestedInput
    booking?: BookingUpdateManyWithoutBranchNestedInput
    events?: EventsUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    events?: EventsUncheckedUpdateManyWithoutBranchNestedInput
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableJsonNullValueInput | InputJsonValue
    amenity?: BranchUpdateamenityInput | string[]
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    bookingCount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUpdateWithoutPropertyInput = {
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutEventsNestedInput
    evbooking?: EvbookingUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evbooking?: EvbookingUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateManyBranchInput = {
    id?: number
    propertyId?: number | null
    tableId?: number | null
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsCreateManyBranchInput = {
    id?: number
    propertyId: number
    location?: string | null
    mapLocation?: string | null
    address?: string | null
    capacity?: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RolePermissionCreateManyBranchInput = {
    id?: number
    roleName: string
    permissions?: RolePermissionCreatepermissionsInput | string[]
    status?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutBranchInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUpdateWithoutBranchInput = {
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutEventNestedInput
    evbooking?: EvbookingUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evbooking?: EvbookingUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapLocation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolePermissionUpdateWithoutBranchInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateManyWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdatepermissionsInput | string[]
    status?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyTableInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    seatBedId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutTableInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    seatBed?: SeatBedUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    seatBedId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManySeatBedInput = {
    id?: number
    propertyId?: number | null
    branchId: number
    tableId?: number | null
    ownerId?: number | null
    customerId?: number | null
    customerName: string
    phoneNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    slot?: string | null
    comment?: string | null
    customerRequest?: string | null
    cancelReason?: string | null
    guestNumber?: number | null
    amount?: number
    vat?: number
    discount?: number
    grandTotal?: number
    status?: $Enums.BookingStatus
    bookingType?: string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutSeatBedInput = {
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutBookingNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingNestedInput
    table?: TableUpdateOneWithoutBookingNestedInput
    owner?: OwnerUpdateOneWithoutBookingNestedInput
    customer?: UserUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutSeatBedInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutSeatBedInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    customerRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    guestNumber?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    vat?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    grandTotal?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingType?: NullableStringFieldUpdateOperationsInput | string | null
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvbookingCreateManyEventInput = {
    id?: number
    username: string
    phoneNumber: string
    email?: string | null
    address?: string | null
    ticketNumber: string
    person?: number
    price?: number
    amount?: number
    vat?: number
    payStatus: $Enums.PaymentStatus
    eventDate: Date | string
    status?: boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt: Date | string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvbookingUpdateWithoutEventInput = {
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvbookingUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvbookingUncheckedUpdateManyWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    person?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    vat?: FloatFieldUpdateOperationsInput | number
    payStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    optionalData?: NullableJsonNullValueInput | InputJsonValue
    issueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: number
    paymentDate?: Date | string | null
    paymentInfo?: string | null
    status: $Enums.PaymentStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OwnerCountOutputTypeDefaultArgs instead
     */
    export type OwnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionCountOutputTypeDefaultArgs instead
     */
    export type RolePermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyCountOutputTypeDefaultArgs instead
     */
    export type PropertyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableCountOutputTypeDefaultArgs instead
     */
    export type TableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeatBedCountOutputTypeDefaultArgs instead
     */
    export type SeatBedCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeatBedCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventsCountOutputTypeDefaultArgs instead
     */
    export type EventsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerDefaultArgs instead
     */
    export type OwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use wishListDefaultArgs instead
     */
    export type wishListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = wishListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyDefaultArgs instead
     */
    export type PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableDefaultArgs instead
     */
    export type TableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeatBedDefaultArgs instead
     */
    export type SeatBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeatBedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodDefaultArgs instead
     */
    export type FoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionDefaultArgs instead
     */
    export type SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventsDefaultArgs instead
     */
    export type EventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AmenitiesDefaultArgs instead
     */
    export type AmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AmenitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CuisineDefaultArgs instead
     */
    export type CuisineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CuisineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvbookingDefaultArgs instead
     */
    export type EvbookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvbookingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}